# zephyr-schema

High-performance binary serialization protocol that's **26% smaller** and **12% faster** than Kiwi.

## üöÄ Try It Live

**[Interactive Demo](https://aliadelelroby.github.io/zephyr/)** - See Zephyr in action with live encoding/decoding, benchmarks, and TypeScript examples.

## Features

- **Smaller payloads**: Delta encoding, bit packing, half-precision floats
- **Faster encoding/decoding**: Optimized for modern JavaScript engines
- **Superior TypeScript support**: Full type safety with enum objects, type guards, and separate input/output types
- **Native Maps**: First-class support for `map<K, V>` types
- **Zero dependencies**: Works in browsers and Node.js

## Installation

```bash
npm install zephyr-schema
```

## Quick Start

### JavaScript

Create a schema file called `test.zephyr`:

```
message Test {
  int x = 1;
}
```

Then use it in your code:

```javascript
const zephyr = require("zephyr-schema");
const fs = require("fs");

const schema = zephyr.compileSchema(
  zephyr.parseSchema(fs.readFileSync("test.zephyr", "utf8"))
);

const buffer = schema.encodeTest({ x: 123 });
const test = schema.decodeTest(buffer);

// Fields in a Zephyr "message" are optional
if (test.x !== undefined) {
  console.log("x is", test.x);
}
```

### TypeScript

Generate TypeScript definitions from your schema:

```bash
npx zephyrc --schema test.zephyr --ts test.ts
```

This generates a file with full type safety:

```typescript
// Generated by Zephyr Schema Compiler

/** Enum: Status */
export const Status = {
  PENDING: "PENDING" as const,
  ACTIVE: "ACTIVE" as const,
} as const;

export type Status = (typeof Status)[keyof typeof Status];

/** Numeric values for Status */
export const StatusValues = {
  PENDING: 0,
  ACTIVE: 1,
} as const;

/** Message: Test */
export interface Test {
  x?: number;
}

/** Input type for encoding Test */
export interface TestInput {
  x?: number;
}

/** Compiled Zephyr Schema interface */
export interface Schema {
  encodeTest(message: TestInput): Uint8Array;
  decodeTest(buffer: Uint8Array): Test;
}
```

Use it in your TypeScript code:

```typescript
import { Test, Schema } from "./test";
import { compileSchema, parseSchema } from "zephyr-schema";
import { readFileSync } from "fs";

const schema: Schema = compileSchema(
  parseSchema(readFileSync("test.zephyr", "utf8"))
);
const buffer: Uint8Array = schema.encodeTest({ x: 123 });
const test: Test = schema.decodeTest(buffer);

if (test.x !== undefined) {
  console.log("x is", test.x);
}
```

## CLI Options

```bash
npx zephyrc --help

Usage: zephyrc [OPTIONS]

Options:
  --help                Print this message.
  --schema [PATH]       The schema file to use.
  --js [PATH]           Generate JavaScript code.
  --ts [PATH]           Generate TypeScript type definitions.
  --ts-readonly         Make decoded types readonly (use with --ts).
  --ts-guards           Generate type guard functions (use with --ts).
  --ts-no-input-types   Don't generate separate input types (use with --ts).
  --cpp [PATH]          Generate C++ code.
  --text [PATH]         Encode the schema as text.
  --binary [PATH]       Encode the schema as a binary blob.
  --root-type [NAME]    Set the root type for JSON.
  --to-json [PATH]      Convert a binary file to JSON.
  --from-json [PATH]    Convert a JSON file to binary.
```

### Examples

```bash
# Generate JavaScript encoder/decoder
zephyrc --schema test.zephyr --js test.js

# Generate TypeScript definitions
zephyrc --schema test.zephyr --ts test.ts

# Generate TypeScript with type guards and readonly types
zephyrc --schema test.zephyr --ts test.ts --ts-readonly --ts-guards

# Generate binary schema for forwards compatibility
zephyrc --schema test.zephyr --binary test.bzephyr

# Convert JSON to binary
zephyrc --schema test.zephyr --root-type Test --from-json data.json
```

## TypeScript Advantages over Kiwi

| Feature                | Kiwi     | Zephyr                    |
| ---------------------- | -------- | ------------------------- |
| Enum as runtime object | ‚ùå       | ‚úÖ `Status.PENDING`       |
| Enum numeric values    | ‚ùå       | ‚úÖ `StatusValues.PENDING` |
| Reverse enum mapping   | ‚ùå       | ‚úÖ `StatusNames[0]`       |
| Type-safe Schema       | ‚ùå `any` | ‚úÖ `typeof Status`        |
| Input/Output types     | ‚ùå       | ‚úÖ `TestInput` / `Test`   |
| Type guards            | ‚ùå       | ‚úÖ `isTest(value)`        |
| Readonly option        | ‚ùå       | ‚úÖ `--ts-readonly`        |
| JSDoc comments         | ‚ùå       | ‚úÖ                        |

## Schema Syntax

### Enums

```
enum Status {
  PENDING = 0;
  ACTIVE = 1;
  COMPLETED = 2;
}
```

### Structs (all fields required)

```
struct Point {
  float x;
  float y;
}
```

### Messages (all fields optional)

```
message User {
  uint id = 1;
  string name = 2;
  string email = 3;
  Status status = 4;
  Point[] locations = 5;
  map<string, int> metadata = 6;
}
```

### Native Types

| Type        | Description                      |
| ----------- | -------------------------------- |
| `bool`      | Boolean value                    |
| `byte`      | 8-bit unsigned integer           |
| `int`       | Variable-length signed integer   |
| `uint`      | Variable-length unsigned integer |
| `int64`     | 64-bit signed integer (BigInt)   |
| `uint64`    | 64-bit unsigned integer (BigInt) |
| `float`     | 32-bit floating point            |
| `float16`   | 16-bit half-precision float      |
| `string`    | UTF-8 string                     |
| `T[]`       | Array of T                       |
| `map<K, V>` | Key-value map                    |

## Forwards Compatibility

Bundle the schema with your data for forwards compatibility:

```bash
# Convert schema to binary format
zephyrc --schema test.zephyr --binary test.bzephyr
```

```javascript
const zephyr = require("zephyr-schema");
const fs = require("fs");

// Load binary schema
const binarySchema = fs.readFileSync("test.bzephyr");
const schema = zephyr.compileSchema(
  zephyr.decodeBinarySchema(new zephyr.ByteBuffer(binarySchema))
);
```

## Performance

Compared to Kiwi across 8 test scenarios:

- **26% smaller** average payload size
- **12% faster** average encode/decode speed
- **84% smaller** boolean arrays (bit packing)
- **50% smaller** sequential numbers (delta encoding)

## License

MIT
