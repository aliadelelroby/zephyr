import { Schema, Definition, Field } from "./schema";
import { error, quote } from "./util";

interface RustOptions {
  serde?: boolean;
  derive_copy?: boolean;
  builder?: boolean;
}

function rustType(
  definitions: { [name: string]: Definition },
  field: Field,
  isArray: boolean,
  forBorrow: boolean = false
): string {
  let type: string;

  switch (field.type) {
    case "bool":
      type = "bool";
      break;
    case "byte":
      type = "u8";
      break;
    case "int":
      type = "i32";
      break;
    case "uint":
      type = "u32";
      break;
    case "float":
      type = "f32";
      break;
    case "float16":
      type = "f32";
      break;
    case "double":
      type = "f64";
      break;
    case "string":
      type = forBorrow ? "Cow<'a, str>" : "String";
      break;
    case "bytes":
      type = forBorrow ? "Cow<'a, [u8]>" : "Vec<u8>";
      break;
    case "int64":
      type = "i64";
      break;
    case "uint64":
      type = "u64";
      break;
    default: {
      const definition = definitions[field.type!];
      if (!definition) {
        error(
          "Invalid type " +
            quote(field.type!) +
            " for field " +
            quote(field.name),
          field.line,
          field.column
        );
      }
      type = definition.name;
      break;
    }
  }

  if (field.isMap && field.keyType && field.type) {
    const keyType =
      field.keyType === "string"
        ? forBorrow
          ? "Cow<'a, str>"
          : "String"
        : rustPrimitiveType(field.keyType);
    return `HashMap<${keyType}, ${type}>`;
  }

  if (field.isFixedArray && field.arraySize !== undefined) {
    return `[${type}; ${field.arraySize}]`;
  }

  if (isArray || field.isArray) {
    return `Vec<${type}>`;
  }

  return type;
}

function rustPrimitiveType(type: string): string {
  switch (type) {
    case "bool":
      return "bool";
    case "byte":
      return "u8";
    case "int":
      return "i32";
    case "uint":
      return "u32";
    case "float":
      return "f32";
    case "float16":
      return "f32";
    case "double":
      return "f64";
    case "int64":
      return "i64";
    case "uint64":
      return "u64";
    case "string":
      return "String";
    default:
      return type;
  }
}

function toSnakeCase(name: string): string {
  return name
    .replace(/([A-Z])/g, "_$1")
    .toLowerCase()
    .replace(/^_/, "")
    .replace(/__+/g, "_");
}

function isMessageType(
  type: string,
  definitions: { [name: string]: Definition }
): boolean {
  return type in definitions && definitions[type].kind === "MESSAGE";
}

function isPrimitiveType(type: string): boolean {
  return [
    "bool",
    "byte",
    "int",
    "uint",
    "float",
    "float16",
    "double",
    "int64",
    "uint64",
  ].includes(type);
}

export function compileSchemaRust(
  schema: Schema,
  options: RustOptions = {}
): string {
  const { serde = true, derive_copy = false, builder = true } = options;
  const definitions: { [name: string]: Definition } = {};
  const rust: string[] = [];

  rust.push("//! Generated by Zephyr Schema Compiler");
  rust.push("//! Do not edit manually");
  rust.push("//!");
  rust.push(
    "//! This module provides strongly-typed structs for Zephyr binary serialization."
  );
  rust.push(
    "//! Unlike Kiwi's dynamic Value approach, Zephyr generates compile-time type safety."
  );
  rust.push("");
  rust.push("#![allow(dead_code)]");
  rust.push("#![allow(unused_imports)]");
  rust.push("#![allow(clippy::all)]");
  rust.push("");
  rust.push("use std::borrow::Cow;");
  rust.push("use std::collections::HashMap;");
  rust.push("use std::io::{Error, ErrorKind, Result};");
  rust.push("");

  if (serde) {
    rust.push('#[cfg(feature = "serde")]');
    rust.push("use serde::{Deserialize, Serialize};");
    rust.push("");
  }

  for (const definition of schema.definitions) {
    definitions[definition.name] = definition;
  }

  // Generate ByteBuffer implementation
  generateByteBuffer(rust);

  // Generate enums first (they may be referenced by structs)
  for (const definition of schema.definitions) {
    if (definition.kind === "ENUM") {
      generateEnum(definition, rust, serde);
    }
  }

  // Generate structs and messages
  for (const definition of schema.definitions) {
    if (definition.kind === "STRUCT") {
      generateStruct(
        definition,
        definitions,
        rust,
        serde,
        derive_copy,
        builder
      );
    } else if (definition.kind === "MESSAGE") {
      generateMessage(definition, definitions, rust, serde, builder);
    } else if (definition.kind !== "ENUM") {
      error(
        "Invalid definition kind " + quote(definition.kind),
        definition.line,
        definition.column
      );
    }
  }

  // Generate traits
  generateTraits(rust);

  // Generate implementations
  for (const definition of schema.definitions) {
    if (definition.kind === "STRUCT") {
      generateStructImpl(definition, definitions, rust);
    } else if (definition.kind === "MESSAGE") {
      generateMessageImpl(definition, definitions, rust);
    }
  }

  // Generate schema metadata
  generateSchemaMetadata(schema, rust);

  if (schema.package !== null) {
    const modName = toSnakeCase(schema.package);
    rust.unshift(`pub mod ${modName} {`);
    rust.push("}");
  }

  rust.push("");
  return rust.join("\n");
}

function generateByteBuffer(rust: string[]): void {
  rust.push(
    "// ============================================================================"
  );
  rust.push("// ByteBuffer - Efficient binary serialization");
  rust.push(
    "// ============================================================================"
  );
  rust.push("");
  rust.push(
    "/// A high-performance byte buffer for Zephyr binary serialization."
  );
  rust.push("///");
  rust.push("/// # Example");
  rust.push("/// ```");
  rust.push("/// let mut bb = ByteBuffer::new();");
  rust.push("/// bb.write_var_uint(42);");
  rust.push('/// bb.write_string("hello");');
  rust.push("/// let bytes = bb.into_bytes();");
  rust.push("/// ```");
  rust.push("#[derive(Debug, Default, Clone)]");
  rust.push("pub struct ByteBuffer {");
  rust.push("    data: Vec<u8>,");
  rust.push("    index: usize,");
  rust.push("}");
  rust.push("");
  rust.push("impl ByteBuffer {");
  rust.push("    /// Creates a new empty ByteBuffer with default capacity.");
  rust.push("    #[inline]");
  rust.push("    pub fn new() -> Self {");
  rust.push("        Self { data: Vec::with_capacity(256), index: 0 }");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Creates a new ByteBuffer with the specified capacity.");
  rust.push("    #[inline]");
  rust.push("    pub fn with_capacity(capacity: usize) -> Self {");
  rust.push("        Self { data: Vec::with_capacity(capacity), index: 0 }");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Creates a ByteBuffer from existing bytes for reading.");
  rust.push("    #[inline]");
  rust.push("    pub fn from_bytes(data: Vec<u8>) -> Self {");
  rust.push("        Self { data, index: 0 }");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Creates a ByteBuffer from a byte slice for reading.");
  rust.push("    #[inline]");
  rust.push("    pub fn from_slice(data: &[u8]) -> Self {");
  rust.push("        Self { data: data.to_vec(), index: 0 }");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Returns the underlying bytes as a slice.");
  rust.push("    #[inline]");
  rust.push("    pub fn as_bytes(&self) -> &[u8] {");
  rust.push("        &self.data");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Consumes the buffer and returns the underlying bytes.");
  rust.push("    #[inline]");
  rust.push("    pub fn into_bytes(self) -> Vec<u8> {");
  rust.push("        self.data");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Returns the current read position.");
  rust.push("    #[inline]");
  rust.push("    pub fn position(&self) -> usize {");
  rust.push("        self.index");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Returns the total length of the buffer.");
  rust.push("    #[inline]");
  rust.push("    pub fn len(&self) -> usize {");
  rust.push("        self.data.len()");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Returns true if the buffer is empty.");
  rust.push("    #[inline]");
  rust.push("    pub fn is_empty(&self) -> bool {");
  rust.push("        self.data.is_empty()");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Returns true if all bytes have been read.");
  rust.push("    #[inline]");
  rust.push("    pub fn is_finished(&self) -> bool {");
  rust.push("        self.index >= self.data.len()");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Resets the read position to the beginning.");
  rust.push("    #[inline]");
  rust.push("    pub fn reset(&mut self) {");
  rust.push("        self.index = 0;");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Clears the buffer completely.");
  rust.push("    #[inline]");
  rust.push("    pub fn clear(&mut self) {");
  rust.push("        self.data.clear();");
  rust.push("        self.index = 0;");
  rust.push("    }");
  rust.push("");

  // Write methods
  rust.push("    // ========== Write Methods ==========");
  rust.push("");
  rust.push("    #[inline]");
  rust.push("    pub fn write_byte(&mut self, value: u8) {");
  rust.push("        self.data.push(value);");
  rust.push("    }");
  rust.push("");
  rust.push("    #[inline]");
  rust.push("    pub fn write_bool(&mut self, value: bool) {");
  rust.push("        self.data.push(if value { 1 } else { 0 });");
  rust.push("    }");
  rust.push("");
  rust.push(
    "    /// Writes a variable-length unsigned 32-bit integer (1-5 bytes)."
  );
  rust.push("    #[inline]");
  rust.push("    pub fn write_var_uint(&mut self, mut value: u32) {");
  rust.push("        // Fast path for small values");
  rust.push("        if value < 128 {");
  rust.push("            self.data.push(value as u8);");
  rust.push("            return;");
  rust.push("        }");
  rust.push("        loop {");
  rust.push("            let byte = (value & 0x7F) as u8;");
  rust.push("            value >>= 7;");
  rust.push("            if value == 0 {");
  rust.push("                self.data.push(byte);");
  rust.push("                break;");
  rust.push("            }");
  rust.push("            self.data.push(byte | 0x80);");
  rust.push("        }");
  rust.push("    }");
  rust.push("");
  rust.push(
    "    /// Writes a variable-length signed 32-bit integer using zigzag encoding."
  );
  rust.push("    #[inline]");
  rust.push("    pub fn write_var_int(&mut self, value: i32) {");
  rust.push(
    "        self.write_var_uint(((value << 1) ^ (value >> 31)) as u32);"
  );
  rust.push("    }");
  rust.push("");
  rust.push(
    "    /// Writes a variable-length unsigned 64-bit integer (1-10 bytes)."
  );
  rust.push("    #[inline]");
  rust.push("    pub fn write_var_uint64(&mut self, mut value: u64) {");
  rust.push("        loop {");
  rust.push("            let byte = (value & 0x7F) as u8;");
  rust.push("            value >>= 7;");
  rust.push("            if value == 0 {");
  rust.push("                self.data.push(byte);");
  rust.push("                break;");
  rust.push("            }");
  rust.push("            self.data.push(byte | 0x80);");
  rust.push("        }");
  rust.push("    }");
  rust.push("");
  rust.push(
    "    /// Writes a variable-length signed 64-bit integer using zigzag encoding."
  );
  rust.push("    #[inline]");
  rust.push("    pub fn write_var_int64(&mut self, value: i64) {");
  rust.push(
    "        self.write_var_uint64(((value << 1) ^ (value >> 63)) as u64);"
  );
  rust.push("    }");
  rust.push("");
  rust.push("    /// Writes a 32-bit float (4 bytes, little-endian).");
  rust.push("    #[inline]");
  rust.push("    pub fn write_var_float(&mut self, value: f32) {");
  rust.push("        self.data.extend_from_slice(&value.to_le_bytes());");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Writes a 64-bit double (8 bytes, little-endian).");
  rust.push("    #[inline]");
  rust.push("    pub fn write_double(&mut self, value: f64) {");
  rust.push("        self.data.extend_from_slice(&value.to_le_bytes());");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Writes a length-prefixed UTF-8 string.");
  rust.push("    #[inline]");
  rust.push("    pub fn write_string(&mut self, value: &str) {");
  rust.push("        let bytes = value.as_bytes();");
  rust.push("        self.write_var_uint(bytes.len() as u32);");
  rust.push("        self.data.extend_from_slice(bytes);");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Writes a length-prefixed byte array.");
  rust.push("    #[inline]");
  rust.push("    pub fn write_bytes(&mut self, value: &[u8]) {");
  rust.push("        self.write_var_uint(value.len() as u32);");
  rust.push("        self.data.extend_from_slice(value);");
  rust.push("    }");
  rust.push("");

  // Read methods
  rust.push("    // ========== Read Methods ==========");
  rust.push("");
  rust.push("    #[inline]");
  rust.push("    pub fn read_byte(&mut self) -> Result<u8> {");
  rust.push("        if self.index >= self.data.len() {");
  rust.push(
    '            return Err(Error::new(ErrorKind::UnexpectedEof, "buffer underflow"));'
  );
  rust.push("        }");
  rust.push("        let value = self.data[self.index];");
  rust.push("        self.index += 1;");
  rust.push("        Ok(value)");
  rust.push("    }");
  rust.push("");
  rust.push("    #[inline]");
  rust.push("    pub fn read_bool(&mut self) -> Result<bool> {");
  rust.push("        Ok(self.read_byte()? != 0)");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Reads a variable-length unsigned 32-bit integer.");
  rust.push("    #[inline]");
  rust.push("    pub fn read_var_uint(&mut self) -> Result<u32> {");
  rust.push("        let mut value: u32 = 0;");
  rust.push("        let mut shift: u32 = 0;");
  rust.push("        loop {");
  rust.push("            let byte = self.read_byte()?;");
  rust.push("            value |= ((byte & 0x7F) as u32) << shift;");
  rust.push("            if byte & 0x80 == 0 {");
  rust.push("                break;");
  rust.push("            }");
  rust.push("            shift += 7;");
  rust.push("            if shift > 35 {");
  rust.push(
    '                return Err(Error::new(ErrorKind::InvalidData, "varint overflow"));'
  );
  rust.push("            }");
  rust.push("        }");
  rust.push("        Ok(value)");
  rust.push("    }");
  rust.push("");
  rust.push(
    "    /// Reads a variable-length signed 32-bit integer (zigzag decoded)."
  );
  rust.push("    #[inline]");
  rust.push("    pub fn read_var_int(&mut self) -> Result<i32> {");
  rust.push("        let value = self.read_var_uint()?;");
  rust.push("        Ok(((value >> 1) as i32) ^ -((value & 1) as i32))");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Reads a variable-length unsigned 64-bit integer.");
  rust.push("    #[inline]");
  rust.push("    pub fn read_var_uint64(&mut self) -> Result<u64> {");
  rust.push("        let mut value: u64 = 0;");
  rust.push("        let mut shift: u32 = 0;");
  rust.push("        loop {");
  rust.push("            let byte = self.read_byte()?;");
  rust.push("            value |= ((byte & 0x7F) as u64) << shift;");
  rust.push("            if byte & 0x80 == 0 {");
  rust.push("                break;");
  rust.push("            }");
  rust.push("            shift += 7;");
  rust.push("            if shift > 70 {");
  rust.push(
    '                return Err(Error::new(ErrorKind::InvalidData, "varint64 overflow"));'
  );
  rust.push("            }");
  rust.push("        }");
  rust.push("        Ok(value)");
  rust.push("    }");
  rust.push("");
  rust.push(
    "    /// Reads a variable-length signed 64-bit integer (zigzag decoded)."
  );
  rust.push("    #[inline]");
  rust.push("    pub fn read_var_int64(&mut self) -> Result<i64> {");
  rust.push("        let value = self.read_var_uint64()?;");
  rust.push("        Ok(((value >> 1) as i64) ^ -((value & 1) as i64))");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Reads a 32-bit float (4 bytes, little-endian).");
  rust.push("    #[inline]");
  rust.push("    pub fn read_var_float(&mut self) -> Result<f32> {");
  rust.push("        if self.index + 4 > self.data.len() {");
  rust.push(
    '            return Err(Error::new(ErrorKind::UnexpectedEof, "buffer underflow"));'
  );
  rust.push("        }");
  rust.push(
    "        let bytes: [u8; 4] = self.data[self.index..self.index + 4].try_into().unwrap();"
  );
  rust.push("        self.index += 4;");
  rust.push("        Ok(f32::from_le_bytes(bytes))");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Reads a 64-bit double (8 bytes, little-endian).");
  rust.push("    #[inline]");
  rust.push("    pub fn read_double(&mut self) -> Result<f64> {");
  rust.push("        if self.index + 8 > self.data.len() {");
  rust.push(
    '            return Err(Error::new(ErrorKind::UnexpectedEof, "buffer underflow"));'
  );
  rust.push("        }");
  rust.push(
    "        let bytes: [u8; 8] = self.data[self.index..self.index + 8].try_into().unwrap();"
  );
  rust.push("        self.index += 8;");
  rust.push("        Ok(f64::from_le_bytes(bytes))");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Reads a length-prefixed UTF-8 string.");
  rust.push("    #[inline]");
  rust.push("    pub fn read_string(&mut self) -> Result<String> {");
  rust.push("        let len = self.read_var_uint()? as usize;");
  rust.push("        if self.index + len > self.data.len() {");
  rust.push(
    '            return Err(Error::new(ErrorKind::UnexpectedEof, "string overflow"));'
  );
  rust.push("        }");
  rust.push("        let bytes = &self.data[self.index..self.index + len];");
  rust.push("        self.index += len;");
  rust.push("        String::from_utf8(bytes.to_vec())");
  rust.push(
    '            .map_err(|_| Error::new(ErrorKind::InvalidData, "invalid UTF-8"))'
  );
  rust.push("    }");
  rust.push("");
  rust.push("    /// Reads a length-prefixed byte array.");
  rust.push("    #[inline]");
  rust.push("    pub fn read_bytes(&mut self) -> Result<Vec<u8>> {");
  rust.push("        let len = self.read_var_uint()? as usize;");
  rust.push("        if self.index + len > self.data.len() {");
  rust.push(
    '            return Err(Error::new(ErrorKind::UnexpectedEof, "bytes overflow"));'
  );
  rust.push("        }");
  rust.push(
    "        let bytes = self.data[self.index..self.index + len].to_vec();"
  );
  rust.push("        self.index += len;");
  rust.push("        Ok(bytes)");
  rust.push("    }");
  rust.push("}");
  rust.push("");
}

function generateEnum(
  definition: Definition,
  rust: string[],
  serde: boolean
): void {
  const { name, fields } = definition;

  rust.push(
    "// ============================================================================"
  );
  rust.push(`// Enum: ${name}`);
  rust.push(
    "// ============================================================================"
  );
  rust.push("");
  rust.push(`/// ${name} enum with ${fields.length} variants.`);

  let derives = "#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]";
  if (serde) {
    derives =
      '#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]\n#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]';
  }
  rust.push(derives);
  rust.push("#[repr(u32)]");
  rust.push(`pub enum ${name} {`);

  for (let j = 0; j < fields.length; j++) {
    const field = fields[j];
    const defaultAttr = j === 0 ? "    #[default]\n" : "";
    rust.push(`${defaultAttr}    ${field.name} = ${field.value},`);
  }

  rust.push("}");
  rust.push("");

  // Impl block with helper methods
  rust.push(`impl ${name} {`);
  rust.push("    /// All variants of this enum.");
  rust.push(`    pub const ALL: &'static [Self] = &[`);
  for (const field of fields) {
    rust.push(`        Self::${field.name},`);
  }
  rust.push("    ];");
  rust.push("");
  rust.push("    /// Creates from a numeric value, returns None if invalid.");
  rust.push("    #[inline]");
  rust.push("    pub const fn from_u32(value: u32) -> Option<Self> {");
  rust.push("        match value {");
  for (const field of fields) {
    rust.push(`            ${field.value} => Some(Self::${field.name}),`);
  }
  rust.push("            _ => None,");
  rust.push("        }");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Returns the string representation.");
  rust.push("    #[inline]");
  rust.push("    pub const fn as_str(&self) -> &'static str {");
  rust.push("        match self {");
  for (const field of fields) {
    rust.push(`            Self::${field.name} => "${field.name}",`);
  }
  rust.push("        }");
  rust.push("    }");
  rust.push("");
  rust.push("    /// Returns the numeric value.");
  rust.push("    #[inline]");
  rust.push("    pub const fn value(&self) -> u32 {");
  rust.push("        *self as u32");
  rust.push("    }");
  rust.push("}");
  rust.push("");

  // Display impl
  rust.push(`impl std::fmt::Display for ${name} {`);
  rust.push(
    "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {"
  );
  rust.push('        write!(f, "{}", self.as_str())');
  rust.push("    }");
  rust.push("}");
  rust.push("");

  // TryFrom impl
  rust.push(`impl TryFrom<u32> for ${name} {`);
  rust.push("    type Error = Error;");
  rust.push("");
  rust.push("    fn try_from(value: u32) -> Result<Self> {");
  rust.push(`        Self::from_u32(value).ok_or_else(|| Error::new(`);
  rust.push(`            ErrorKind::InvalidData,`);
  rust.push(`            format!("invalid ${name} value: {}", value)`);
  rust.push("        ))");
  rust.push("    }");
  rust.push("}");
  rust.push("");
}

function generateStruct(
  definition: Definition,
  definitions: { [name: string]: Definition },
  rust: string[],
  serde: boolean,
  derive_copy: boolean,
  builder: boolean
): void {
  const { name, fields } = definition;
  const activeFields = fields.filter((f) => !f.isDeprecated);

  rust.push(
    "// ============================================================================"
  );
  rust.push(`// Struct: ${name}`);
  rust.push(
    "// ============================================================================"
  );
  rust.push("");
  rust.push(`/// ${name} struct - all fields are required.`);

  let derives = "#[derive(Debug, Clone, Default, PartialEq)]";
  if (derive_copy && canDeriveCopy(activeFields, definitions)) {
    derives = "#[derive(Debug, Clone, Copy, Default, PartialEq)]";
  }
  if (serde) {
    derives +=
      '\n#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]';
  }
  rust.push(derives);
  rust.push(`pub struct ${name} {`);

  for (const field of activeFields) {
    const fieldName = toSnakeCase(field.name);
    const type = rustType(definitions, field, field.isArray);
    rust.push(`    pub ${fieldName}: ${type},`);
  }

  rust.push("}");
  rust.push("");

  // Builder pattern
  if (builder && activeFields.length > 0) {
    rust.push(`impl ${name} {`);
    rust.push("    /// Creates a new instance with default values.");
    rust.push("    #[inline]");
    rust.push("    pub fn new() -> Self {");
    rust.push("        Self::default()");
    rust.push("    }");
    rust.push("");

    for (const field of activeFields) {
      const fieldName = toSnakeCase(field.name);
      const type = rustType(definitions, field, field.isArray);
      const paramType = isSimpleType(field) ? type : `impl Into<${type}>`;
      const intoCall = isSimpleType(field) ? "" : ".into()";

      rust.push(`    /// Sets the \`${fieldName}\` field.`);
      rust.push("    #[inline]");
      rust.push(
        `    pub fn with_${fieldName}(mut self, value: ${paramType}) -> Self {`
      );
      rust.push(`        self.${fieldName} = value${intoCall};`);
      rust.push("        self");
      rust.push("    }");
      rust.push("");
    }

    rust.push("}");
    rust.push("");
  }
}

function generateMessage(
  definition: Definition,
  definitions: { [name: string]: Definition },
  rust: string[],
  serde: boolean,
  builder: boolean
): void {
  const { name, fields } = definition;
  const activeFields = fields.filter((f) => !f.isDeprecated);

  rust.push(
    "// ============================================================================"
  );
  rust.push(`// Message: ${name}`);
  rust.push(
    "// ============================================================================"
  );
  rust.push("");
  rust.push(`/// ${name} message - all fields are optional.`);

  let derives = "#[derive(Debug, Clone, Default, PartialEq)]";
  if (serde) {
    derives +=
      '\n#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]';
  }
  rust.push(derives);
  rust.push(`pub struct ${name} {`);

  for (const field of activeFields) {
    const fieldName = toSnakeCase(field.name);
    const type = rustType(definitions, field, field.isArray);
    if (serde) {
      rust.push(
        `    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]`
      );
    }
    rust.push(`    pub ${fieldName}: Option<${type}>,`);
  }

  rust.push("}");
  rust.push("");

  // Builder pattern and helper methods
  if (activeFields.length > 0) {
    rust.push(`impl ${name} {`);
    rust.push("    /// Creates a new empty message.");
    rust.push("    #[inline]");
    rust.push("    pub fn new() -> Self {");
    rust.push("        Self::default()");
    rust.push("    }");
    rust.push("");

    if (builder) {
      for (const field of activeFields) {
        const fieldName = toSnakeCase(field.name);
        const type = rustType(definitions, field, field.isArray);
        const paramType = isSimpleType(field) ? type : `impl Into<${type}>`;
        const intoCall = isSimpleType(field) ? "" : ".into()";

        rust.push(`    /// Sets the \`${fieldName}\` field.`);
        rust.push("    #[inline]");
        rust.push(
          `    pub fn with_${fieldName}(mut self, value: ${paramType}) -> Self {`
        );
        rust.push(`        self.${fieldName} = Some(value${intoCall});`);
        rust.push("        self");
        rust.push("    }");
        rust.push("");
      }
    }

    // Getter methods
    for (const field of activeFields) {
      const fieldName = toSnakeCase(field.name);
      const type = rustType(definitions, field, field.isArray);
      const returnType = getGetterReturnType(type);
      const returnExpr = getGetterReturnExpr(type, fieldName);

      rust.push(`    /// Gets the \`${fieldName}\` field if present.`);
      rust.push("    #[inline]");
      rust.push(`    pub fn ${fieldName}(&self) -> ${returnType} {`);
      rust.push(`        ${returnExpr}`);
      rust.push("    }");
      rust.push("");
    }

    // has_* methods
    for (const field of activeFields) {
      const fieldName = toSnakeCase(field.name);
      rust.push(`    /// Returns true if \`${fieldName}\` is set.`);
      rust.push("    #[inline]");
      rust.push(`    pub fn has_${fieldName}(&self) -> bool {`);
      rust.push(`        self.${fieldName}.is_some()`);
      rust.push("    }");
      rust.push("");
    }

    rust.push("}");
    rust.push("");
  }
}

function getGetterReturnType(type: string): string {
  if (type === "String") return "Option<&str>";
  if (type === "Vec<u8>") return "Option<&[u8]>";
  if (type.startsWith("Vec<"))
    return `Option<&${type.replace("Vec<", "[").replace(">", "]")}>`;
  if (type.startsWith("HashMap<")) return `Option<&${type}>`;
  if (isPrimitiveRustType(type)) return `Option<${type}>`;
  return `Option<&${type}>`;
}

function getGetterReturnExpr(type: string, fieldName: string): string {
  if (type === "String") return `self.${fieldName}.as_deref()`;
  if (type === "Vec<u8>") return `self.${fieldName}.as_deref()`;
  if (type.startsWith("Vec<")) return `self.${fieldName}.as_deref()`;
  if (type.startsWith("HashMap<")) return `self.${fieldName}.as_ref()`;
  if (isPrimitiveRustType(type)) return `self.${fieldName}`;
  return `self.${fieldName}.as_ref()`;
}

function isPrimitiveRustType(type: string): boolean {
  return ["bool", "u8", "i32", "u32", "f32", "f64", "i64", "u64"].includes(
    type
  );
}

function isSimpleType(field: Field): boolean {
  return (
    isPrimitiveType(field.type!) &&
    !field.isArray &&
    !field.isMap &&
    !field.isFixedArray
  );
}

function canDeriveCopy(
  fields: Field[],
  definitions: { [name: string]: Definition }
): boolean {
  return fields.every((f) => {
    if (f.type === "string" || f.type === "bytes") return false;
    if (f.isArray || f.isMap) return false;
    if (f.type && f.type in definitions) {
      const def = definitions[f.type];
      if (def.kind === "MESSAGE") return false;
      if (def.kind === "STRUCT") {
        return canDeriveCopy(
          def.fields.filter((ff) => !ff.isDeprecated),
          definitions
        );
      }
    }
    return true;
  });
}

function generateTraits(rust: string[]): void {
  rust.push(
    "// ============================================================================"
  );
  rust.push("// Encode/Decode Traits");
  rust.push(
    "// ============================================================================"
  );
  rust.push("");
  rust.push("/// Trait for types that can be encoded to Zephyr binary format.");
  rust.push("pub trait Encode {");
  rust.push("    /// Encodes this value to the given ByteBuffer.");
  rust.push("    fn encode(&self, bb: &mut ByteBuffer);");
  rust.push("");
  rust.push("    /// Encodes this value and returns the bytes.");
  rust.push("    fn to_bytes(&self) -> Vec<u8> {");
  rust.push("        let mut bb = ByteBuffer::new();");
  rust.push("        self.encode(&mut bb);");
  rust.push("        bb.into_bytes()");
  rust.push("    }");
  rust.push("}");
  rust.push("");
  rust.push(
    "/// Trait for types that can be decoded from Zephyr binary format."
  );
  rust.push("pub trait Decode: Sized {");
  rust.push("    /// Decodes a value from the given ByteBuffer.");
  rust.push("    fn decode(bb: &mut ByteBuffer) -> Result<Self>;");
  rust.push("");
  rust.push("    /// Decodes a value from bytes.");
  rust.push("    fn from_bytes(data: &[u8]) -> Result<Self> {");
  rust.push("        let mut bb = ByteBuffer::from_slice(data);");
  rust.push("        Self::decode(&mut bb)");
  rust.push("    }");
  rust.push("}");
  rust.push("");
}

function generateStructImpl(
  definition: Definition,
  definitions: { [name: string]: Definition },
  rust: string[]
): void {
  const { name, fields } = definition;
  const activeFields = fields.filter((f) => !f.isDeprecated);

  // Encode impl
  rust.push(`impl Encode for ${name} {`);
  rust.push("    fn encode(&self, bb: &mut ByteBuffer) {");

  for (const field of activeFields) {
    const fieldName = toSnakeCase(field.name);
    generateFieldEncode(
      field,
      `self.${fieldName}`,
      definitions,
      rust,
      "        "
    );
  }

  rust.push("    }");
  rust.push("}");
  rust.push("");

  // Decode impl
  rust.push(`impl Decode for ${name} {`);
  rust.push("    fn decode(bb: &mut ByteBuffer) -> Result<Self> {");
  rust.push("        Ok(Self {");

  for (const field of activeFields) {
    const fieldName = toSnakeCase(field.name);
    rust.push(
      `            ${fieldName}: ${generateFieldDecode(field, definitions)}?,`
    );
  }

  rust.push("        })");
  rust.push("    }");
  rust.push("}");
  rust.push("");
}

function generateMessageImpl(
  definition: Definition,
  definitions: { [name: string]: Definition },
  rust: string[]
): void {
  const { name, fields } = definition;
  const activeFields = fields.filter((f) => !f.isDeprecated);

  // Encode impl
  rust.push(`impl Encode for ${name} {`);
  rust.push("    fn encode(&self, bb: &mut ByteBuffer) {");

  for (const field of activeFields) {
    const fieldName = toSnakeCase(field.name);
    rust.push(`        if let Some(ref value) = self.${fieldName} {`);
    rust.push(`            bb.write_var_uint(${field.value});`);
    generateFieldEncode(
      field,
      "value",
      definitions,
      rust,
      "            ",
      true
    );
    rust.push("        }");
  }

  rust.push("        bb.write_var_uint(0);");
  rust.push("    }");
  rust.push("}");
  rust.push("");

  // Decode impl
  rust.push(`impl Decode for ${name} {`);
  rust.push("    fn decode(bb: &mut ByteBuffer) -> Result<Self> {");
  rust.push("        let mut result = Self::default();");
  rust.push("        loop {");
  rust.push("            let field_id = bb.read_var_uint()?;");
  rust.push("            match field_id {");
  rust.push("                0 => return Ok(result),");

  for (const field of activeFields) {
    const fieldName = toSnakeCase(field.name);
    rust.push(
      `                ${
        field.value
      } => result.${fieldName} = Some(${generateFieldDecode(
        field,
        definitions
      )}?),`
    );
  }

  rust.push("                unknown => return Err(Error::new(");
  rust.push("                    ErrorKind::InvalidData,");
  rust.push(
    `                    format!("unknown field id {} in ${name}", unknown)`
  );
  rust.push("                )),");
  rust.push("            }");
  rust.push("        }");
  rust.push("    }");
  rust.push("}");
  rust.push("");
}

function generateFieldEncode(
  field: Field,
  accessor: string,
  definitions: { [name: string]: Definition },
  rust: string[],
  indent: string,
  isRef: boolean = false
): void {
  const derefPrefix = isRef ? "" : "";

  if (field.isFixedArray && field.arraySize !== undefined) {
    rust.push(`${indent}for item in ${derefPrefix}${accessor}.iter() {`);
    rust.push(
      `${indent}    ${generateValueEncode(field.type!, "*item", definitions)}`
    );
    rust.push(`${indent}}`);
  } else if (field.isArray) {
    rust.push(`${indent}bb.write_var_uint(${accessor}.len() as u32);`);
    rust.push(`${indent}for item in ${accessor}.iter() {`);
    rust.push(
      `${indent}    ${generateValueEncode(field.type!, "item", definitions)}`
    );
    rust.push(`${indent}}`);
  } else if (field.isMap) {
    rust.push(`${indent}bb.write_var_uint(${accessor}.len() as u32);`);
    rust.push(`${indent}for (key, val) in ${accessor}.iter() {`);
    if (field.keyType === "string") {
      rust.push(`${indent}    bb.write_string(key);`);
    } else {
      rust.push(`${indent}    bb.write_var_uint(*key as u32);`);
    }
    rust.push(
      `${indent}    ${generateValueEncode(field.type!, "val", definitions)}`
    );
    rust.push(`${indent}}`);
  } else {
    rust.push(
      `${indent}${generateValueEncode(field.type!, accessor, definitions)}`
    );
  }
}

function generateValueEncode(
  type: string,
  accessor: string,
  definitions: { [name: string]: Definition }
): string {
  switch (type) {
    case "bool":
      return `bb.write_bool(*${accessor});`;
    case "byte":
      return `bb.write_byte(*${accessor});`;
    case "int":
      return `bb.write_var_int(*${accessor});`;
    case "uint":
      return `bb.write_var_uint(*${accessor});`;
    case "float":
    case "float16":
      return `bb.write_var_float(*${accessor});`;
    case "double":
      return `bb.write_double(*${accessor});`;
    case "string":
      return `bb.write_string(${accessor});`;
    case "bytes":
      return `bb.write_bytes(${accessor});`;
    case "int64":
      return `bb.write_var_int64(*${accessor});`;
    case "uint64":
      return `bb.write_var_uint64(*${accessor});`;
    default:
      if (type in definitions && definitions[type].kind === "ENUM") {
        return `bb.write_var_uint(${accessor}.value());`;
      }
      return `${accessor}.encode(bb);`;
  }
}

function generateFieldDecode(
  field: Field,
  definitions: { [name: string]: Definition }
): string {
  if (field.isFixedArray && field.arraySize !== undefined) {
    const decode = generateValueDecode(field.type!, definitions);
    return `{
                let mut arr: [_; ${field.arraySize}] = Default::default();
                for item in arr.iter_mut() {
                    *item = ${decode}?;
                }
                arr
            }`;
  } else if (field.isArray) {
    const decode = generateValueDecode(field.type!, definitions);
    return `{
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(${decode}?);
                }
                vec
            }`;
  } else if (field.isMap) {
    const decode = generateValueDecode(field.type!, definitions);
    const keyDecode =
      field.keyType === "string"
        ? "bb.read_string()?"
        : `bb.read_var_uint()? as ${rustPrimitiveType(field.keyType!)}`;
    return `{
                let count = bb.read_var_uint()? as usize;
                let mut map = HashMap::with_capacity(count);
                for _ in 0..count {
                    let key = ${keyDecode};
                    let value = ${decode}?;
                    map.insert(key, value);
                }
                map
            }`;
  } else {
    return generateValueDecode(field.type!, definitions);
  }
}

function generateValueDecode(
  type: string,
  definitions: { [name: string]: Definition }
): string {
  switch (type) {
    case "bool":
      return "bb.read_bool()";
    case "byte":
      return "bb.read_byte()";
    case "int":
      return "bb.read_var_int()";
    case "uint":
      return "bb.read_var_uint()";
    case "float":
    case "float16":
      return "bb.read_var_float()";
    case "double":
      return "bb.read_double()";
    case "string":
      return "bb.read_string()";
    case "bytes":
      return "bb.read_bytes()";
    case "int64":
      return "bb.read_var_int64()";
    case "uint64":
      return "bb.read_var_uint64()";
    default:
      if (type in definitions && definitions[type].kind === "ENUM") {
        return `${type}::try_from(bb.read_var_uint()?)`;
      }
      return `${type}::decode(bb)`;
  }
}

function generateSchemaMetadata(schema: Schema, rust: string[]): void {
  rust.push(
    "// ============================================================================"
  );
  rust.push("// Schema Metadata");
  rust.push(
    "// ============================================================================"
  );
  rust.push("");
  rust.push("/// Schema version information.");
  rust.push("pub mod schema {");
  rust.push(
    `    pub const PACKAGE: Option<&str> = ${
      schema.package ? `Some("${schema.package}")` : "None"
    };`
  );
  rust.push(
    `    pub const DEFINITION_COUNT: usize = ${schema.definitions.length};`
  );
  rust.push("}");
  rust.push("");
}
