import { Schema, Field, Definition } from "./schema";
import { error, quote } from "./util";

interface TypeScriptOptions {
  readonly?: boolean;
  branded?: boolean;
  typeGuards?: boolean;
  inputTypes?: boolean;
}

function getTypeScriptType(
  field: Field,
  definitions: Definition[],
  options: TypeScriptOptions = {}
): string {
  const { readonly = false } = options;

  if (field.isMap && field.keyType && field.type) {
    const keyType = field.keyType === "string" ? "string" : "number";
    const valueType = resolveFieldType(field.type, definitions);
    return readonly
      ? `Readonly<Record<${keyType}, ${valueType}>>`
      : `Record<${keyType}, ${valueType}>`;
  }

  let type = resolveFieldType(field.type || "any", definitions);

  if (field.type === "byte" && field.isArray) {
    return "Uint8Array";
  }

  if (field.isFixedArray && field.arraySize !== undefined) {
    const tuple = Array(field.arraySize).fill(type).join(", ");
    return readonly ? `readonly [${tuple}]` : `[${tuple}]`;
  }

  if (field.isArray) {
    return readonly ? `readonly ${type}[]` : `${type}[]`;
  }

  return type;
}

function resolveFieldType(type: string, definitions: Definition[]): string {
  switch (type) {
    case "bool":
      return "boolean";
    case "byte":
    case "int":
    case "uint":
    case "float":
    case "float16":
    case "double":
      return "number";
    case "int64":
    case "uint64":
      return "bigint";
    case "string":
      return "string";
    case "bytes":
      return "Uint8Array";
    default:
      return type;
  }
}

function isDefinedType(type: string, definitions: Definition[]): boolean {
  return definitions.some((d) => d.name === type);
}

function isMessageType(type: string, definitions: Definition[]): boolean {
  return definitions.some((d) => d.name === type && d.kind === "MESSAGE");
}

export function compileSchemaTypeScript(
  schema: Schema,
  options: TypeScriptOptions = {}
): string {
  const {
    readonly = false,
    branded = false,
    typeGuards = false,
    inputTypes = true,
  } = options;

  let indent = "";
  const lines: string[] = [];

  lines.push("// Generated by Zephyr Schema Compiler");
  lines.push("// Do not edit manually");
  lines.push("");

  if (schema.package !== null) {
    lines.push(`export namespace ${schema.package} {`);
    indent = "  ";
  }

  // Generate branded types if enabled
  if (branded) {
    lines.push(indent + "/** Branded type for compile-time type safety */");
    lines.push(
      indent + "type Brand<T, B extends string> = T & { readonly __brand: B };"
    );
    lines.push("");
  }

  // Generate enum types
  for (const definition of schema.definitions) {
    if (definition.kind === "ENUM") {
      generateEnumType(definition, lines, indent);
    }
  }

  // Generate struct/message interfaces
  for (const definition of schema.definitions) {
    if (definition.kind === "STRUCT" || definition.kind === "MESSAGE") {
      generateInterfaceType(
        definition,
        schema.definitions,
        lines,
        indent,
        readonly,
        inputTypes
      );
    } else if (definition.kind !== "ENUM") {
      error(
        "Invalid definition kind " + quote(definition.kind),
        definition.line,
        definition.column
      );
    }
  }

  // Generate type guards if enabled
  if (typeGuards) {
    generateTypeGuards(schema.definitions, lines, indent);
  }

  // Generate Schema interface
  generateSchemaInterface(schema.definitions, lines, indent, inputTypes);

  if (schema.package !== null) {
    lines.push("}");
  }

  lines.push("");
  return lines.join("\n");
}

function generateEnumType(
  definition: Definition,
  lines: string[],
  indent: string
): void {
  const { name, fields } = definition;

  lines.push(indent + `/** Enum: ${name} */`);
  lines.push(indent + `export const ${name} = {`);

  for (let j = 0; j < fields.length; j++) {
    const field = fields[j];
    lines.push(
      indent + `  ${field.name}: ${JSON.stringify(field.name)} as const,`
    );
  }

  lines.push(indent + "} as const;");
  lines.push("");

  // Generate the type from the const object
  lines.push(
    indent + `export type ${name} = (typeof ${name})[keyof typeof ${name}];`
  );
  lines.push("");

  // Generate numeric value mapping
  lines.push(indent + `/** Numeric values for ${name} */`);
  lines.push(indent + `export const ${name}Values = {`);

  for (let j = 0; j < fields.length; j++) {
    const field = fields[j];
    lines.push(indent + `  ${field.name}: ${field.value},`);
  }

  lines.push(indent + "} as const;");
  lines.push("");

  // Generate reverse mapping (value to name)
  lines.push(indent + `/** Reverse mapping for ${name} (value to name) */`);
  lines.push(indent + `export const ${name}Names: Record<number, ${name}> = {`);

  for (let j = 0; j < fields.length; j++) {
    const field = fields[j];
    lines.push(indent + `  ${field.value}: ${JSON.stringify(field.name)},`);
  }

  lines.push(indent + "};");
  lines.push("");
}

function generateInterfaceType(
  definition: Definition,
  definitions: Definition[],
  lines: string[],
  indent: string,
  readonly: boolean,
  inputTypes: boolean
): void {
  const { name, kind, fields } = definition;
  const isMessage = kind === "MESSAGE";

  lines.push(
    indent + `/** ${kind === "STRUCT" ? "Struct" : "Message"}: ${name} */`
  );
  lines.push(indent + `export interface ${name} {`);

  for (const field of fields) {
    if (field.isDeprecated) {
      continue;
    }

    const type = getTypeScriptType(field, definitions, { readonly });
    const optional = isMessage ? "?" : "";
    const readonlyMod = readonly ? "readonly " : "";

    lines.push(indent + `  ${readonlyMod}${field.name}${optional}: ${type};`);
  }

  lines.push(indent + "}");
  lines.push("");

  // Generate input type for messages (all fields optional, nested messages also partial)
  if (inputTypes && isMessage) {
    lines.push(
      indent + `/** Input type for encoding ${name} (all fields optional) */`
    );
    lines.push(indent + `export interface ${name}Input {`);

    for (const field of fields) {
      if (field.isDeprecated) {
        continue;
      }

      let type = getTypeScriptType(field, definitions, { readonly: false });

      // For nested message types, also make them partial
      if (
        field.type &&
        isMessageType(field.type, definitions) &&
        !field.isArray &&
        !field.isMap
      ) {
        type = `${field.type}Input`;
      } else if (
        field.type &&
        isMessageType(field.type, definitions) &&
        field.isArray
      ) {
        type = `${field.type}Input[]`;
      }

      lines.push(indent + `  ${field.name}?: ${type};`);
    }

    lines.push(indent + "}");
    lines.push("");
  }
}

function generateTypeGuards(
  definitions: Definition[],
  lines: string[],
  indent: string
): void {
  lines.push(indent + "// Type Guards");
  lines.push("");

  for (const definition of definitions) {
    if (definition.kind === "ENUM") {
      const { name, fields } = definition;
      const values = fields.map((f) => JSON.stringify(f.name)).join(", ");

      lines.push(indent + `/** Type guard for ${name} */`);
      lines.push(
        indent + `export function is${name}(value: unknown): value is ${name} {`
      );
      lines.push(indent + `  return [${values}].includes(value as ${name});`);
      lines.push(indent + "}");
      lines.push("");
    } else if (definition.kind === "STRUCT" || definition.kind === "MESSAGE") {
      const { name, fields } = definition;
      const isMessage = definition.kind === "MESSAGE";

      lines.push(indent + `/** Type guard for ${name} */`);
      lines.push(
        indent + `export function is${name}(value: unknown): value is ${name} {`
      );
      lines.push(
        indent +
          "  if (typeof value !== 'object' || value === null) return false;"
      );
      lines.push(indent + `  const obj = value as Record<string, unknown>;`);

      for (const field of fields) {
        if (field.isDeprecated) continue;

        const fieldCheck = generateFieldTypeCheck(field, isMessage);
        if (fieldCheck) {
          lines.push(indent + `  ${fieldCheck}`);
        }
      }

      lines.push(indent + "  return true;");
      lines.push(indent + "}");
      lines.push("");
    }
  }
}

function generateFieldTypeCheck(field: Field, isMessage: boolean): string {
  const { name, type, isArray, isMap } = field;
  const accessor = `obj[${JSON.stringify(name)}]`;

  if (isMessage) {
    // For messages, fields are optional
    return `if (${accessor} !== undefined && ${accessor} !== null) { /* check ${name} */ }`;
  }

  // For structs, fields are required
  if (isMap) {
    return `if (typeof ${accessor} !== 'object') return false;`;
  }

  if (isArray) {
    return `if (!Array.isArray(${accessor})) return false;`;
  }

  switch (type) {
    case "bool":
      return `if (typeof ${accessor} !== 'boolean') return false;`;
    case "byte":
    case "int":
    case "uint":
    case "float":
    case "float16":
    case "double":
      return `if (typeof ${accessor} !== 'number') return false;`;
    case "int64":
    case "uint64":
      return `if (typeof ${accessor} !== 'bigint') return false;`;
    case "string":
      return `if (typeof ${accessor} !== 'string') return false;`;
    case "bytes":
      return `if (!(${accessor} instanceof Uint8Array)) return false;`;
    default:
      return `if (typeof ${accessor} !== 'object') return false;`;
  }
}

function generateSchemaInterface(
  definitions: Definition[],
  lines: string[],
  indent: string,
  inputTypes: boolean
): void {
  lines.push(indent + "/** Compiled Zephyr Schema interface */");
  lines.push(indent + "export interface Schema {");

  for (const definition of definitions) {
    const { name, kind } = definition;

    if (kind === "ENUM") {
      lines.push(indent + `  /** Enum values for ${name} */`);
      lines.push(indent + `  ${name}: typeof ${name};`);
    } else if (kind === "STRUCT" || kind === "MESSAGE") {
      const inputType =
        inputTypes && kind === "MESSAGE" ? `${name}Input` : name;

      lines.push(indent + `  /** Encode ${name} to binary */`);
      lines.push(
        indent + `  encode${name}(message: ${inputType}): Uint8Array;`
      );
      lines.push(indent + `  /** Decode binary to ${name} */`);
      lines.push(indent + `  decode${name}(buffer: Uint8Array): ${name};`);
    }
  }

  lines.push(indent + "}");
  lines.push("");
}

export function compileSchemaTypeScriptDeclaration(schema: Schema): string {
  return compileSchemaTypeScript(schema, {
    readonly: true,
    branded: false,
    typeGuards: true,
    inputTypes: true,
  });
}
