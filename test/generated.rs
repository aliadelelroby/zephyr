pub mod test {
//! Generated by Zephyr Schema Compiler
//! Do not edit manually
//!
//! This module provides strongly-typed structs for Zephyr binary serialization.
//! Unlike Kiwi's dynamic Value approach, Zephyr generates compile-time type safety.

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(clippy::all)]

use std::borrow::Cow;
use std::collections::HashMap;
use std::io::{Error, ErrorKind, Result};

#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

// ============================================================================
// ByteBuffer - Efficient binary serialization
// ============================================================================

/// A high-performance byte buffer for Zephyr binary serialization.
///
/// # Example
/// ```
/// let mut bb = ByteBuffer::new();
/// bb.write_var_uint(42);
/// bb.write_string("hello");
/// let bytes = bb.into_bytes();
/// ```
#[derive(Debug, Default, Clone)]
pub struct ByteBuffer {
    data: Vec<u8>,
    index: usize,
}

impl ByteBuffer {
    /// Creates a new empty ByteBuffer with default capacity.
    #[inline]
    pub fn new() -> Self {
        Self { data: Vec::with_capacity(256), index: 0 }
    }

    /// Creates a new ByteBuffer with the specified capacity.
    #[inline]
    pub fn with_capacity(capacity: usize) -> Self {
        Self { data: Vec::with_capacity(capacity), index: 0 }
    }

    /// Creates a ByteBuffer from existing bytes for reading.
    #[inline]
    pub fn from_bytes(data: Vec<u8>) -> Self {
        Self { data, index: 0 }
    }

    /// Creates a ByteBuffer from a byte slice for reading.
    #[inline]
    pub fn from_slice(data: &[u8]) -> Self {
        Self { data: data.to_vec(), index: 0 }
    }

    /// Returns the underlying bytes as a slice.
    #[inline]
    pub fn as_bytes(&self) -> &[u8] {
        &self.data
    }

    /// Consumes the buffer and returns the underlying bytes.
    #[inline]
    pub fn into_bytes(self) -> Vec<u8> {
        self.data
    }

    /// Returns the current read position.
    #[inline]
    pub fn position(&self) -> usize {
        self.index
    }

    /// Returns the total length of the buffer.
    #[inline]
    pub fn len(&self) -> usize {
        self.data.len()
    }

    /// Returns true if the buffer is empty.
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.data.is_empty()
    }

    /// Returns true if all bytes have been read.
    #[inline]
    pub fn is_finished(&self) -> bool {
        self.index >= self.data.len()
    }

    /// Resets the read position to the beginning.
    #[inline]
    pub fn reset(&mut self) {
        self.index = 0;
    }

    /// Clears the buffer completely.
    #[inline]
    pub fn clear(&mut self) {
        self.data.clear();
        self.index = 0;
    }

    // ========== Write Methods ==========

    #[inline]
    pub fn write_byte(&mut self, value: u8) {
        self.data.push(value);
    }

    #[inline]
    pub fn write_bool(&mut self, value: bool) {
        self.data.push(if value { 1 } else { 0 });
    }

    /// Writes a variable-length unsigned 32-bit integer (1-5 bytes).
    #[inline]
    pub fn write_var_uint(&mut self, mut value: u32) {
        // Fast path for small values
        if value < 128 {
            self.data.push(value as u8);
            return;
        }
        loop {
            let byte = (value & 0x7F) as u8;
            value >>= 7;
            if value == 0 {
                self.data.push(byte);
                break;
            }
            self.data.push(byte | 0x80);
        }
    }

    /// Writes a variable-length signed 32-bit integer using zigzag encoding.
    #[inline]
    pub fn write_var_int(&mut self, value: i32) {
        self.write_var_uint(((value << 1) ^ (value >> 31)) as u32);
    }

    /// Writes a variable-length unsigned 64-bit integer (1-10 bytes).
    #[inline]
    pub fn write_var_uint64(&mut self, mut value: u64) {
        loop {
            let byte = (value & 0x7F) as u8;
            value >>= 7;
            if value == 0 {
                self.data.push(byte);
                break;
            }
            self.data.push(byte | 0x80);
        }
    }

    /// Writes a variable-length signed 64-bit integer using zigzag encoding.
    #[inline]
    pub fn write_var_int64(&mut self, value: i64) {
        self.write_var_uint64(((value << 1) ^ (value >> 63)) as u64);
    }

    /// Writes a 32-bit float (4 bytes, little-endian).
    #[inline]
    pub fn write_var_float(&mut self, value: f32) {
        self.data.extend_from_slice(&value.to_le_bytes());
    }

    /// Writes a 64-bit double (8 bytes, little-endian).
    #[inline]
    pub fn write_double(&mut self, value: f64) {
        self.data.extend_from_slice(&value.to_le_bytes());
    }

    /// Writes a length-prefixed UTF-8 string.
    #[inline]
    pub fn write_string(&mut self, value: &str) {
        let bytes = value.as_bytes();
        self.write_var_uint(bytes.len() as u32);
        self.data.extend_from_slice(bytes);
    }

    /// Writes a length-prefixed byte array.
    #[inline]
    pub fn write_bytes(&mut self, value: &[u8]) {
        self.write_var_uint(value.len() as u32);
        self.data.extend_from_slice(value);
    }

    // ========== Read Methods ==========

    #[inline]
    pub fn read_byte(&mut self) -> Result<u8> {
        if self.index >= self.data.len() {
            return Err(Error::new(ErrorKind::UnexpectedEof, "buffer underflow"));
        }
        let value = self.data[self.index];
        self.index += 1;
        Ok(value)
    }

    #[inline]
    pub fn read_bool(&mut self) -> Result<bool> {
        Ok(self.read_byte()? != 0)
    }

    /// Reads a variable-length unsigned 32-bit integer.
    #[inline]
    pub fn read_var_uint(&mut self) -> Result<u32> {
        let mut value: u32 = 0;
        let mut shift: u32 = 0;
        loop {
            let byte = self.read_byte()?;
            value |= ((byte & 0x7F) as u32) << shift;
            if byte & 0x80 == 0 {
                break;
            }
            shift += 7;
            if shift > 35 {
                return Err(Error::new(ErrorKind::InvalidData, "varint overflow"));
            }
        }
        Ok(value)
    }

    /// Reads a variable-length signed 32-bit integer (zigzag decoded).
    #[inline]
    pub fn read_var_int(&mut self) -> Result<i32> {
        let value = self.read_var_uint()?;
        Ok(((value >> 1) as i32) ^ -((value & 1) as i32))
    }

    /// Reads a variable-length unsigned 64-bit integer.
    #[inline]
    pub fn read_var_uint64(&mut self) -> Result<u64> {
        let mut value: u64 = 0;
        let mut shift: u32 = 0;
        loop {
            let byte = self.read_byte()?;
            value |= ((byte & 0x7F) as u64) << shift;
            if byte & 0x80 == 0 {
                break;
            }
            shift += 7;
            if shift > 70 {
                return Err(Error::new(ErrorKind::InvalidData, "varint64 overflow"));
            }
        }
        Ok(value)
    }

    /// Reads a variable-length signed 64-bit integer (zigzag decoded).
    #[inline]
    pub fn read_var_int64(&mut self) -> Result<i64> {
        let value = self.read_var_uint64()?;
        Ok(((value >> 1) as i64) ^ -((value & 1) as i64))
    }

    /// Reads a 32-bit float (4 bytes, little-endian).
    #[inline]
    pub fn read_var_float(&mut self) -> Result<f32> {
        if self.index + 4 > self.data.len() {
            return Err(Error::new(ErrorKind::UnexpectedEof, "buffer underflow"));
        }
        let bytes: [u8; 4] = self.data[self.index..self.index + 4].try_into().unwrap();
        self.index += 4;
        Ok(f32::from_le_bytes(bytes))
    }

    /// Reads a 64-bit double (8 bytes, little-endian).
    #[inline]
    pub fn read_double(&mut self) -> Result<f64> {
        if self.index + 8 > self.data.len() {
            return Err(Error::new(ErrorKind::UnexpectedEof, "buffer underflow"));
        }
        let bytes: [u8; 8] = self.data[self.index..self.index + 8].try_into().unwrap();
        self.index += 8;
        Ok(f64::from_le_bytes(bytes))
    }

    /// Reads a length-prefixed UTF-8 string.
    #[inline]
    pub fn read_string(&mut self) -> Result<String> {
        let len = self.read_var_uint()? as usize;
        if self.index + len > self.data.len() {
            return Err(Error::new(ErrorKind::UnexpectedEof, "string overflow"));
        }
        let bytes = &self.data[self.index..self.index + len];
        self.index += len;
        String::from_utf8(bytes.to_vec())
            .map_err(|_| Error::new(ErrorKind::InvalidData, "invalid UTF-8"))
    }

    /// Reads a length-prefixed byte array.
    #[inline]
    pub fn read_bytes(&mut self) -> Result<Vec<u8>> {
        let len = self.read_var_uint()? as usize;
        if self.index + len > self.data.len() {
            return Err(Error::new(ErrorKind::UnexpectedEof, "bytes overflow"));
        }
        let bytes = self.data[self.index..self.index + len].to_vec();
        self.index += len;
        Ok(bytes)
    }
}

// ============================================================================
// Enum: Enum
// ============================================================================

/// Enum enum with 2 variants.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(u32)]
pub enum Enum {
    #[default]
    A = 100,
    B = 200,
}

impl Enum {
    /// All variants of this enum.
    pub const ALL: &'static [Self] = &[
        Self::A,
        Self::B,
    ];

    /// Creates from a numeric value, returns None if invalid.
    #[inline]
    pub const fn from_u32(value: u32) -> Option<Self> {
        match value {
            100 => Some(Self::A),
            200 => Some(Self::B),
            _ => None,
        }
    }

    /// Returns the string representation.
    #[inline]
    pub const fn as_str(&self) -> &'static str {
        match self {
            Self::A => "A",
            Self::B => "B",
        }
    }

    /// Returns the numeric value.
    #[inline]
    pub const fn value(&self) -> u32 {
        *self as u32
    }
}

impl std::fmt::Display for Enum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl TryFrom<u32> for Enum {
    type Error = Error;

    fn try_from(value: u32) -> Result<Self> {
        Self::from_u32(value).ok_or_else(|| Error::new(
            ErrorKind::InvalidData,
            format!("invalid Enum value: {}", value)
        ))
    }
}

// ============================================================================
// Struct: EnumStruct
// ============================================================================

/// EnumStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct EnumStruct {
    pub x: Enum,
    pub y: Vec<Enum>,
}

impl EnumStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Enum>) -> Self {
        self.x = value.into();
        self
    }

    /// Sets the `y` field.
    #[inline]
    pub fn with_y(mut self, value: impl Into<Vec<Enum>>) -> Self {
        self.y = value.into();
        self
    }

}

// ============================================================================
// Struct: BoolStruct
// ============================================================================

/// BoolStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BoolStruct {
    pub x: bool,
}

impl BoolStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: bool) -> Self {
        self.x = value;
        self
    }

}

// ============================================================================
// Struct: ByteStruct
// ============================================================================

/// ByteStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ByteStruct {
    pub x: u8,
}

impl ByteStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: u8) -> Self {
        self.x = value;
        self
    }

}

// ============================================================================
// Struct: IntStruct
// ============================================================================

/// IntStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct IntStruct {
    pub x: i32,
}

impl IntStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: i32) -> Self {
        self.x = value;
        self
    }

}

// ============================================================================
// Struct: UintStruct
// ============================================================================

/// UintStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct UintStruct {
    pub x: u32,
}

impl UintStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: u32) -> Self {
        self.x = value;
        self
    }

}

// ============================================================================
// Struct: Int64Struct
// ============================================================================

/// Int64Struct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Int64Struct {
    pub x: i64,
}

impl Int64Struct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: i64) -> Self {
        self.x = value;
        self
    }

}

// ============================================================================
// Struct: Uint64Struct
// ============================================================================

/// Uint64Struct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Uint64Struct {
    pub x: u64,
}

impl Uint64Struct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: u64) -> Self {
        self.x = value;
        self
    }

}

// ============================================================================
// Struct: FloatStruct
// ============================================================================

/// FloatStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FloatStruct {
    pub x: f32,
}

impl FloatStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: f32) -> Self {
        self.x = value;
        self
    }

}

// ============================================================================
// Struct: Float16Struct
// ============================================================================

/// Float16Struct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Float16Struct {
    pub x: f32,
}

impl Float16Struct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: f32) -> Self {
        self.x = value;
        self
    }

}

// ============================================================================
// Struct: DoubleStruct
// ============================================================================

/// DoubleStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DoubleStruct {
    pub x: f64,
}

impl DoubleStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: f64) -> Self {
        self.x = value;
        self
    }

}

// ============================================================================
// Struct: StringStruct
// ============================================================================

/// StringStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct StringStruct {
    pub x: String,
}

impl StringStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<String>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: BytesStruct
// ============================================================================

/// BytesStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BytesStruct {
    pub x: Vec<u8>,
}

impl BytesStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<u8>>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: CompoundStruct
// ============================================================================

/// CompoundStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CompoundStruct {
    pub x: u32,
    pub y: u32,
}

impl CompoundStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: u32) -> Self {
        self.x = value;
        self
    }

    /// Sets the `y` field.
    #[inline]
    pub fn with_y(mut self, value: u32) -> Self {
        self.y = value;
        self
    }

}

// ============================================================================
// Struct: NestedStruct
// ============================================================================

/// NestedStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct NestedStruct {
    pub a: u32,
    pub b: CompoundStruct,
    pub c: u32,
}

impl NestedStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `a` field.
    #[inline]
    pub fn with_a(mut self, value: u32) -> Self {
        self.a = value;
        self
    }

    /// Sets the `b` field.
    #[inline]
    pub fn with_b(mut self, value: impl Into<CompoundStruct>) -> Self {
        self.b = value.into();
        self
    }

    /// Sets the `c` field.
    #[inline]
    pub fn with_c(mut self, value: u32) -> Self {
        self.c = value;
        self
    }

}

// ============================================================================
// Message: BoolMessage
// ============================================================================

/// BoolMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BoolMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<bool>,
}

impl BoolMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: bool) -> Self {
        self.x = Some(value);
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<bool> {
        self.x
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: ByteMessage
// ============================================================================

/// ByteMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ByteMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<u8>,
}

impl ByteMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: u8) -> Self {
        self.x = Some(value);
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<u8> {
        self.x
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: IntMessage
// ============================================================================

/// IntMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct IntMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<i32>,
}

impl IntMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: i32) -> Self {
        self.x = Some(value);
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<i32> {
        self.x
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: UintMessage
// ============================================================================

/// UintMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct UintMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<u32>,
}

impl UintMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: u32) -> Self {
        self.x = Some(value);
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<u32> {
        self.x
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: Int64Message
// ============================================================================

/// Int64Message message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Int64Message {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<i64>,
}

impl Int64Message {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: i64) -> Self {
        self.x = Some(value);
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<i64> {
        self.x
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: Uint64Message
// ============================================================================

/// Uint64Message message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Uint64Message {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<u64>,
}

impl Uint64Message {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: u64) -> Self {
        self.x = Some(value);
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<u64> {
        self.x
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: FloatMessage
// ============================================================================

/// FloatMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FloatMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<f32>,
}

impl FloatMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: f32) -> Self {
        self.x = Some(value);
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<f32> {
        self.x
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: Float16Message
// ============================================================================

/// Float16Message message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Float16Message {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<f32>,
}

impl Float16Message {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: f32) -> Self {
        self.x = Some(value);
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<f32> {
        self.x
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: DoubleMessage
// ============================================================================

/// DoubleMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DoubleMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<f64>,
}

impl DoubleMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: f64) -> Self {
        self.x = Some(value);
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<f64> {
        self.x
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: StringMessage
// ============================================================================

/// StringMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct StringMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<String>,
}

impl StringMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<String>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&str> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: BytesMessage
// ============================================================================

/// BytesMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BytesMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<u8>>,
}

impl BytesMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<u8>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[u8]> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: CompoundMessage
// ============================================================================

/// CompoundMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CompoundMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<u32>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub y: Option<u32>,
}

impl CompoundMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: u32) -> Self {
        self.x = Some(value);
        self
    }

    /// Sets the `y` field.
    #[inline]
    pub fn with_y(mut self, value: u32) -> Self {
        self.y = Some(value);
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<u32> {
        self.x
    }

    /// Gets the `y` field if present.
    #[inline]
    pub fn y(&self) -> Option<u32> {
        self.y
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    /// Returns true if `y` is set.
    #[inline]
    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

}

// ============================================================================
// Message: NestedMessage
// ============================================================================

/// NestedMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct NestedMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub a: Option<u32>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub b: Option<CompoundMessage>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub c: Option<u32>,
}

impl NestedMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `a` field.
    #[inline]
    pub fn with_a(mut self, value: u32) -> Self {
        self.a = Some(value);
        self
    }

    /// Sets the `b` field.
    #[inline]
    pub fn with_b(mut self, value: impl Into<CompoundMessage>) -> Self {
        self.b = Some(value.into());
        self
    }

    /// Sets the `c` field.
    #[inline]
    pub fn with_c(mut self, value: u32) -> Self {
        self.c = Some(value);
        self
    }

    /// Gets the `a` field if present.
    #[inline]
    pub fn a(&self) -> Option<u32> {
        self.a
    }

    /// Gets the `b` field if present.
    #[inline]
    pub fn b(&self) -> Option<&CompoundMessage> {
        self.b.as_ref()
    }

    /// Gets the `c` field if present.
    #[inline]
    pub fn c(&self) -> Option<u32> {
        self.c
    }

    /// Returns true if `a` is set.
    #[inline]
    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    /// Returns true if `b` is set.
    #[inline]
    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    /// Returns true if `c` is set.
    #[inline]
    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }

}

// ============================================================================
// Struct: BoolArrayStruct
// ============================================================================

/// BoolArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BoolArrayStruct {
    pub x: Vec<bool>,
}

impl BoolArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<bool>>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: ByteArrayStruct
// ============================================================================

/// ByteArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ByteArrayStruct {
    pub x: Vec<u8>,
}

impl ByteArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<u8>>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: IntArrayStruct
// ============================================================================

/// IntArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct IntArrayStruct {
    pub x: Vec<i32>,
}

impl IntArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<i32>>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: UintArrayStruct
// ============================================================================

/// UintArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct UintArrayStruct {
    pub x: Vec<u32>,
}

impl UintArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<u32>>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: Int64ArrayStruct
// ============================================================================

/// Int64ArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Int64ArrayStruct {
    pub x: Vec<i64>,
}

impl Int64ArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<i64>>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: Uint64ArrayStruct
// ============================================================================

/// Uint64ArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Uint64ArrayStruct {
    pub x: Vec<u64>,
}

impl Uint64ArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<u64>>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: FloatArrayStruct
// ============================================================================

/// FloatArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FloatArrayStruct {
    pub x: Vec<f32>,
}

impl FloatArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<f32>>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: Float16ArrayStruct
// ============================================================================

/// Float16ArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Float16ArrayStruct {
    pub x: Vec<f32>,
}

impl Float16ArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<f32>>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: DoubleArrayStruct
// ============================================================================

/// DoubleArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DoubleArrayStruct {
    pub x: Vec<f64>,
}

impl DoubleArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<f64>>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: StringArrayStruct
// ============================================================================

/// StringArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct StringArrayStruct {
    pub x: Vec<String>,
}

impl StringArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<String>>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: BytesArrayStruct
// ============================================================================

/// BytesArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BytesArrayStruct {
    pub x: Vec<Vec<u8>>,
}

impl BytesArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<Vec<u8>>>) -> Self {
        self.x = value.into();
        self
    }

}

// ============================================================================
// Struct: CompoundArrayStruct
// ============================================================================

/// CompoundArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CompoundArrayStruct {
    pub x: Vec<u32>,
    pub y: Vec<u32>,
}

impl CompoundArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<u32>>) -> Self {
        self.x = value.into();
        self
    }

    /// Sets the `y` field.
    #[inline]
    pub fn with_y(mut self, value: impl Into<Vec<u32>>) -> Self {
        self.y = value.into();
        self
    }

}

// ============================================================================
// Message: BoolArrayMessage
// ============================================================================

/// BoolArrayMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BoolArrayMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<bool>>,
}

impl BoolArrayMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<bool>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[bool]> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: ByteArrayMessage
// ============================================================================

/// ByteArrayMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ByteArrayMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<u8>>,
}

impl ByteArrayMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<u8>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[u8]> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: IntArrayMessage
// ============================================================================

/// IntArrayMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct IntArrayMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<i32>>,
}

impl IntArrayMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<i32>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[i32]> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: UintArrayMessage
// ============================================================================

/// UintArrayMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct UintArrayMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<u32>>,
}

impl UintArrayMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<u32>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[u32]> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: Int64ArrayMessage
// ============================================================================

/// Int64ArrayMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Int64ArrayMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<i64>>,
}

impl Int64ArrayMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<i64>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[i64]> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: Uint64ArrayMessage
// ============================================================================

/// Uint64ArrayMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Uint64ArrayMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<u64>>,
}

impl Uint64ArrayMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<u64>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[u64]> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: FloatArrayMessage
// ============================================================================

/// FloatArrayMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FloatArrayMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<f32>>,
}

impl FloatArrayMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<f32>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[f32]> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: Float16ArrayMessage
// ============================================================================

/// Float16ArrayMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Float16ArrayMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<f32>>,
}

impl Float16ArrayMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<f32>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[f32]> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: DoubleArrayMessage
// ============================================================================

/// DoubleArrayMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DoubleArrayMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<f64>>,
}

impl DoubleArrayMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<f64>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[f64]> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: StringArrayMessage
// ============================================================================

/// StringArrayMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct StringArrayMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<String>>,
}

impl StringArrayMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<String>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[String]> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: BytesArrayMessage
// ============================================================================

/// BytesArrayMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BytesArrayMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<Vec<u8>>>,
}

impl BytesArrayMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<Vec<u8>>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[Vec<u8]>> {
        self.x.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: CompoundArrayMessage
// ============================================================================

/// CompoundArrayMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct CompoundArrayMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<Vec<u32>>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub y: Option<Vec<u32>>,
}

impl CompoundArrayMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<Vec<u32>>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Sets the `y` field.
    #[inline]
    pub fn with_y(mut self, value: impl Into<Vec<u32>>) -> Self {
        self.y = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&[u32]> {
        self.x.as_deref()
    }

    /// Gets the `y` field if present.
    #[inline]
    pub fn y(&self) -> Option<&[u32]> {
        self.y.as_deref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    /// Returns true if `y` is set.
    #[inline]
    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

}

// ============================================================================
// Message: RecursiveMessage
// ============================================================================

/// RecursiveMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct RecursiveMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub x: Option<RecursiveMessage>,
}

impl RecursiveMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `x` field.
    #[inline]
    pub fn with_x(mut self, value: impl Into<RecursiveMessage>) -> Self {
        self.x = Some(value.into());
        self
    }

    /// Gets the `x` field if present.
    #[inline]
    pub fn x(&self) -> Option<&RecursiveMessage> {
        self.x.as_ref()
    }

    /// Returns true if `x` is set.
    #[inline]
    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

}

// ============================================================================
// Message: NonDeprecatedMessage
// ============================================================================

/// NonDeprecatedMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct NonDeprecatedMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub a: Option<u32>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub b: Option<u32>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub c: Option<Vec<u32>>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub d: Option<Vec<u32>>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub e: Option<ByteStruct>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub f: Option<ByteStruct>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub g: Option<u32>,
}

impl NonDeprecatedMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `a` field.
    #[inline]
    pub fn with_a(mut self, value: u32) -> Self {
        self.a = Some(value);
        self
    }

    /// Sets the `b` field.
    #[inline]
    pub fn with_b(mut self, value: u32) -> Self {
        self.b = Some(value);
        self
    }

    /// Sets the `c` field.
    #[inline]
    pub fn with_c(mut self, value: impl Into<Vec<u32>>) -> Self {
        self.c = Some(value.into());
        self
    }

    /// Sets the `d` field.
    #[inline]
    pub fn with_d(mut self, value: impl Into<Vec<u32>>) -> Self {
        self.d = Some(value.into());
        self
    }

    /// Sets the `e` field.
    #[inline]
    pub fn with_e(mut self, value: impl Into<ByteStruct>) -> Self {
        self.e = Some(value.into());
        self
    }

    /// Sets the `f` field.
    #[inline]
    pub fn with_f(mut self, value: impl Into<ByteStruct>) -> Self {
        self.f = Some(value.into());
        self
    }

    /// Sets the `g` field.
    #[inline]
    pub fn with_g(mut self, value: u32) -> Self {
        self.g = Some(value);
        self
    }

    /// Gets the `a` field if present.
    #[inline]
    pub fn a(&self) -> Option<u32> {
        self.a
    }

    /// Gets the `b` field if present.
    #[inline]
    pub fn b(&self) -> Option<u32> {
        self.b
    }

    /// Gets the `c` field if present.
    #[inline]
    pub fn c(&self) -> Option<&[u32]> {
        self.c.as_deref()
    }

    /// Gets the `d` field if present.
    #[inline]
    pub fn d(&self) -> Option<&[u32]> {
        self.d.as_deref()
    }

    /// Gets the `e` field if present.
    #[inline]
    pub fn e(&self) -> Option<&ByteStruct> {
        self.e.as_ref()
    }

    /// Gets the `f` field if present.
    #[inline]
    pub fn f(&self) -> Option<&ByteStruct> {
        self.f.as_ref()
    }

    /// Gets the `g` field if present.
    #[inline]
    pub fn g(&self) -> Option<u32> {
        self.g
    }

    /// Returns true if `a` is set.
    #[inline]
    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    /// Returns true if `b` is set.
    #[inline]
    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    /// Returns true if `c` is set.
    #[inline]
    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }

    /// Returns true if `d` is set.
    #[inline]
    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    /// Returns true if `e` is set.
    #[inline]
    pub fn has_e(&self) -> bool {
        self.e.is_some()
    }

    /// Returns true if `f` is set.
    #[inline]
    pub fn has_f(&self) -> bool {
        self.f.is_some()
    }

    /// Returns true if `g` is set.
    #[inline]
    pub fn has_g(&self) -> bool {
        self.g.is_some()
    }

}

// ============================================================================
// Message: DeprecatedMessage
// ============================================================================

/// DeprecatedMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct DeprecatedMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub a: Option<u32>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub c: Option<Vec<u32>>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub e: Option<ByteStruct>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub g: Option<u32>,
}

impl DeprecatedMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `a` field.
    #[inline]
    pub fn with_a(mut self, value: u32) -> Self {
        self.a = Some(value);
        self
    }

    /// Sets the `c` field.
    #[inline]
    pub fn with_c(mut self, value: impl Into<Vec<u32>>) -> Self {
        self.c = Some(value.into());
        self
    }

    /// Sets the `e` field.
    #[inline]
    pub fn with_e(mut self, value: impl Into<ByteStruct>) -> Self {
        self.e = Some(value.into());
        self
    }

    /// Sets the `g` field.
    #[inline]
    pub fn with_g(mut self, value: u32) -> Self {
        self.g = Some(value);
        self
    }

    /// Gets the `a` field if present.
    #[inline]
    pub fn a(&self) -> Option<u32> {
        self.a
    }

    /// Gets the `c` field if present.
    #[inline]
    pub fn c(&self) -> Option<&[u32]> {
        self.c.as_deref()
    }

    /// Gets the `e` field if present.
    #[inline]
    pub fn e(&self) -> Option<&ByteStruct> {
        self.e.as_ref()
    }

    /// Gets the `g` field if present.
    #[inline]
    pub fn g(&self) -> Option<u32> {
        self.g
    }

    /// Returns true if `a` is set.
    #[inline]
    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    /// Returns true if `c` is set.
    #[inline]
    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }

    /// Returns true if `e` is set.
    #[inline]
    pub fn has_e(&self) -> bool {
        self.e.is_some()
    }

    /// Returns true if `g` is set.
    #[inline]
    pub fn has_g(&self) -> bool {
        self.g.is_some()
    }

}

// ============================================================================
// Message: MapMessage
// ============================================================================

/// MapMessage message - all fields are optional.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct MapMessage {
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub metadata: Option<HashMap<String, i32>>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub reverse: Option<HashMap<i32, String>>,
}

impl MapMessage {
    /// Creates a new empty message.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `metadata` field.
    #[inline]
    pub fn with_metadata(mut self, value: impl Into<HashMap<String, i32>>) -> Self {
        self.metadata = Some(value.into());
        self
    }

    /// Sets the `reverse` field.
    #[inline]
    pub fn with_reverse(mut self, value: impl Into<HashMap<i32, String>>) -> Self {
        self.reverse = Some(value.into());
        self
    }

    /// Gets the `metadata` field if present.
    #[inline]
    pub fn metadata(&self) -> Option<&HashMap<String, i32>> {
        self.metadata.as_ref()
    }

    /// Gets the `reverse` field if present.
    #[inline]
    pub fn reverse(&self) -> Option<&HashMap<i32, String>> {
        self.reverse.as_ref()
    }

    /// Returns true if `metadata` is set.
    #[inline]
    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    /// Returns true if `reverse` is set.
    #[inline]
    pub fn has_reverse(&self) -> bool {
        self.reverse.is_some()
    }

}

// ============================================================================
// Struct: FixedArrayStruct
// ============================================================================

/// FixedArrayStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct FixedArrayStruct {
    pub position: [f32; 4],
    pub indices: [i32; 8],
}

impl FixedArrayStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `position` field.
    #[inline]
    pub fn with_position(mut self, value: impl Into<[f32; 4]>) -> Self {
        self.position = value.into();
        self
    }

    /// Sets the `indices` field.
    #[inline]
    pub fn with_indices(mut self, value: impl Into<[i32; 8]>) -> Self {
        self.indices = value.into();
        self
    }

}

// ============================================================================
// Struct: SortedStruct
// ============================================================================

/// SortedStruct struct - all fields are required.
#[derive(Debug, Clone, Default, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SortedStruct {
    pub a1: bool,
    pub b1: u8,
    pub c1: i32,
    pub d1: u32,
    pub e1: f32,
    pub e1h: f32,
    pub e1d: f64,
    pub f1: String,
    pub g1: i64,
    pub h1: u64,
    pub a2: bool,
    pub b2: u8,
    pub c2: i32,
    pub d2: u32,
    pub e2: f32,
    pub e2h: f32,
    pub e2d: f64,
    pub f2: String,
    pub g2: i64,
    pub h2: u64,
    pub a3: Vec<bool>,
    pub b3: Vec<u8>,
    pub c3: Vec<i32>,
    pub d3: Vec<u32>,
    pub e3: Vec<f32>,
    pub e3h: Vec<f32>,
    pub e3d: Vec<f64>,
    pub f3: Vec<String>,
    pub g3: Vec<i64>,
    pub h3: Vec<u64>,
}

impl SortedStruct {
    /// Creates a new instance with default values.
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `a1` field.
    #[inline]
    pub fn with_a1(mut self, value: bool) -> Self {
        self.a1 = value;
        self
    }

    /// Sets the `b1` field.
    #[inline]
    pub fn with_b1(mut self, value: u8) -> Self {
        self.b1 = value;
        self
    }

    /// Sets the `c1` field.
    #[inline]
    pub fn with_c1(mut self, value: i32) -> Self {
        self.c1 = value;
        self
    }

    /// Sets the `d1` field.
    #[inline]
    pub fn with_d1(mut self, value: u32) -> Self {
        self.d1 = value;
        self
    }

    /// Sets the `e1` field.
    #[inline]
    pub fn with_e1(mut self, value: f32) -> Self {
        self.e1 = value;
        self
    }

    /// Sets the `e1h` field.
    #[inline]
    pub fn with_e1h(mut self, value: f32) -> Self {
        self.e1h = value;
        self
    }

    /// Sets the `e1d` field.
    #[inline]
    pub fn with_e1d(mut self, value: f64) -> Self {
        self.e1d = value;
        self
    }

    /// Sets the `f1` field.
    #[inline]
    pub fn with_f1(mut self, value: impl Into<String>) -> Self {
        self.f1 = value.into();
        self
    }

    /// Sets the `g1` field.
    #[inline]
    pub fn with_g1(mut self, value: i64) -> Self {
        self.g1 = value;
        self
    }

    /// Sets the `h1` field.
    #[inline]
    pub fn with_h1(mut self, value: u64) -> Self {
        self.h1 = value;
        self
    }

    /// Sets the `a2` field.
    #[inline]
    pub fn with_a2(mut self, value: bool) -> Self {
        self.a2 = value;
        self
    }

    /// Sets the `b2` field.
    #[inline]
    pub fn with_b2(mut self, value: u8) -> Self {
        self.b2 = value;
        self
    }

    /// Sets the `c2` field.
    #[inline]
    pub fn with_c2(mut self, value: i32) -> Self {
        self.c2 = value;
        self
    }

    /// Sets the `d2` field.
    #[inline]
    pub fn with_d2(mut self, value: u32) -> Self {
        self.d2 = value;
        self
    }

    /// Sets the `e2` field.
    #[inline]
    pub fn with_e2(mut self, value: f32) -> Self {
        self.e2 = value;
        self
    }

    /// Sets the `e2h` field.
    #[inline]
    pub fn with_e2h(mut self, value: f32) -> Self {
        self.e2h = value;
        self
    }

    /// Sets the `e2d` field.
    #[inline]
    pub fn with_e2d(mut self, value: f64) -> Self {
        self.e2d = value;
        self
    }

    /// Sets the `f2` field.
    #[inline]
    pub fn with_f2(mut self, value: impl Into<String>) -> Self {
        self.f2 = value.into();
        self
    }

    /// Sets the `g2` field.
    #[inline]
    pub fn with_g2(mut self, value: i64) -> Self {
        self.g2 = value;
        self
    }

    /// Sets the `h2` field.
    #[inline]
    pub fn with_h2(mut self, value: u64) -> Self {
        self.h2 = value;
        self
    }

    /// Sets the `a3` field.
    #[inline]
    pub fn with_a3(mut self, value: impl Into<Vec<bool>>) -> Self {
        self.a3 = value.into();
        self
    }

    /// Sets the `b3` field.
    #[inline]
    pub fn with_b3(mut self, value: impl Into<Vec<u8>>) -> Self {
        self.b3 = value.into();
        self
    }

    /// Sets the `c3` field.
    #[inline]
    pub fn with_c3(mut self, value: impl Into<Vec<i32>>) -> Self {
        self.c3 = value.into();
        self
    }

    /// Sets the `d3` field.
    #[inline]
    pub fn with_d3(mut self, value: impl Into<Vec<u32>>) -> Self {
        self.d3 = value.into();
        self
    }

    /// Sets the `e3` field.
    #[inline]
    pub fn with_e3(mut self, value: impl Into<Vec<f32>>) -> Self {
        self.e3 = value.into();
        self
    }

    /// Sets the `e3h` field.
    #[inline]
    pub fn with_e3h(mut self, value: impl Into<Vec<f32>>) -> Self {
        self.e3h = value.into();
        self
    }

    /// Sets the `e3d` field.
    #[inline]
    pub fn with_e3d(mut self, value: impl Into<Vec<f64>>) -> Self {
        self.e3d = value.into();
        self
    }

    /// Sets the `f3` field.
    #[inline]
    pub fn with_f3(mut self, value: impl Into<Vec<String>>) -> Self {
        self.f3 = value.into();
        self
    }

    /// Sets the `g3` field.
    #[inline]
    pub fn with_g3(mut self, value: impl Into<Vec<i64>>) -> Self {
        self.g3 = value.into();
        self
    }

    /// Sets the `h3` field.
    #[inline]
    pub fn with_h3(mut self, value: impl Into<Vec<u64>>) -> Self {
        self.h3 = value.into();
        self
    }

}

// ============================================================================
// Encode/Decode Traits
// ============================================================================

/// Trait for types that can be encoded to Zephyr binary format.
pub trait Encode {
    /// Encodes this value to the given ByteBuffer.
    fn encode(&self, bb: &mut ByteBuffer);

    /// Encodes this value and returns the bytes.
    fn to_bytes(&self) -> Vec<u8> {
        let mut bb = ByteBuffer::new();
        self.encode(&mut bb);
        bb.into_bytes()
    }
}

/// Trait for types that can be decoded from Zephyr binary format.
pub trait Decode: Sized {
    /// Decodes a value from the given ByteBuffer.
    fn decode(bb: &mut ByteBuffer) -> Result<Self>;

    /// Decodes a value from bytes.
    fn from_bytes(data: &[u8]) -> Result<Self> {
        let mut bb = ByteBuffer::from_slice(data);
        Self::decode(&mut bb)
    }
}

impl Encode for EnumStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.value());
        bb.write_var_uint(self.y.len() as u32);
        for item in self.y.iter() {
            bb.write_var_uint(item.value());
        }
    }
}

impl Decode for EnumStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: Enum::try_from(bb.read_var_uint()?)?,
            y: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(Enum::try_from(bb.read_var_uint()?)?);
                }
                vec
            }?,
        })
    }
}

impl Encode for BoolStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_bool(*self.x);
    }
}

impl Decode for BoolStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: bb.read_bool()?,
        })
    }
}

impl Encode for ByteStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_byte(*self.x);
    }
}

impl Decode for ByteStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: bb.read_byte()?,
        })
    }
}

impl Encode for IntStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_int(*self.x);
    }
}

impl Decode for IntStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: bb.read_var_int()?,
        })
    }
}

impl Encode for UintStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(*self.x);
    }
}

impl Decode for UintStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: bb.read_var_uint()?,
        })
    }
}

impl Encode for Int64Struct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_int64(*self.x);
    }
}

impl Decode for Int64Struct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: bb.read_var_int64()?,
        })
    }
}

impl Encode for Uint64Struct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint64(*self.x);
    }
}

impl Decode for Uint64Struct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: bb.read_var_uint64()?,
        })
    }
}

impl Encode for FloatStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_float(*self.x);
    }
}

impl Decode for FloatStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: bb.read_var_float()?,
        })
    }
}

impl Encode for Float16Struct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_float(*self.x);
    }
}

impl Decode for Float16Struct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: bb.read_var_float()?,
        })
    }
}

impl Encode for DoubleStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_double(*self.x);
    }
}

impl Decode for DoubleStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: bb.read_double()?,
        })
    }
}

impl Encode for StringStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_string(self.x);
    }
}

impl Decode for StringStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: bb.read_string()?,
        })
    }
}

impl Encode for BytesStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_bytes(self.x);
    }
}

impl Decode for BytesStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: bb.read_bytes()?,
        })
    }
}

impl Encode for CompoundStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(*self.x);
        bb.write_var_uint(*self.y);
    }
}

impl Decode for CompoundStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: bb.read_var_uint()?,
            y: bb.read_var_uint()?,
        })
    }
}

impl Encode for NestedStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(*self.a);
        self.b.encode(bb);
        bb.write_var_uint(*self.c);
    }
}

impl Decode for NestedStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            a: bb.read_var_uint()?,
            b: CompoundStruct::decode(bb)?,
            c: bb.read_var_uint()?,
        })
    }
}

impl Encode for BoolMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_bool(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for BoolMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(bb.read_bool()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in BoolMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for ByteMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_byte(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for ByteMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(bb.read_byte()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in ByteMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for IntMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_int(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for IntMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(bb.read_var_int()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in IntMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for UintMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for UintMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(bb.read_var_uint()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in UintMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for Int64Message {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_int64(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for Int64Message {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(bb.read_var_int64()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in Int64Message", unknown)
                )),
            }
        }
    }
}

impl Encode for Uint64Message {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint64(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for Uint64Message {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(bb.read_var_uint64()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in Uint64Message", unknown)
                )),
            }
        }
    }
}

impl Encode for FloatMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_float(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for FloatMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(bb.read_var_float()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in FloatMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for Float16Message {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_float(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for Float16Message {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(bb.read_var_float()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in Float16Message", unknown)
                )),
            }
        }
    }
}

impl Encode for DoubleMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_double(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for DoubleMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(bb.read_double()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in DoubleMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for StringMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_string(value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for StringMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(bb.read_string()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in StringMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for BytesMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_bytes(value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for BytesMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(bb.read_bytes()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in BytesMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for CompoundMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(*value);
        }
        if let Some(ref value) = self.y {
            bb.write_var_uint(2);
            bb.write_var_uint(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for CompoundMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(bb.read_var_uint()?),
                2 => result.y = Some(bb.read_var_uint()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in CompoundMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for NestedMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.a {
            bb.write_var_uint(1);
            bb.write_var_uint(*value);
        }
        if let Some(ref value) = self.b {
            bb.write_var_uint(2);
            value.encode(bb);
        }
        if let Some(ref value) = self.c {
            bb.write_var_uint(3);
            bb.write_var_uint(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for NestedMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.a = Some(bb.read_var_uint()?),
                2 => result.b = Some(CompoundMessage::decode(bb)?),
                3 => result.c = Some(bb.read_var_uint()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in NestedMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for BoolArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.len() as u32);
        for item in self.x.iter() {
            bb.write_bool(*item);
        }
    }
}

impl Decode for BoolArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_bool()?);
                }
                vec
            }?,
        })
    }
}

impl Encode for ByteArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.len() as u32);
        for item in self.x.iter() {
            bb.write_byte(*item);
        }
    }
}

impl Decode for ByteArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_byte()?);
                }
                vec
            }?,
        })
    }
}

impl Encode for IntArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.len() as u32);
        for item in self.x.iter() {
            bb.write_var_int(*item);
        }
    }
}

impl Decode for IntArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_int()?);
                }
                vec
            }?,
        })
    }
}

impl Encode for UintArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.len() as u32);
        for item in self.x.iter() {
            bb.write_var_uint(*item);
        }
    }
}

impl Decode for UintArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint()?);
                }
                vec
            }?,
        })
    }
}

impl Encode for Int64ArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.len() as u32);
        for item in self.x.iter() {
            bb.write_var_int64(*item);
        }
    }
}

impl Decode for Int64ArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_int64()?);
                }
                vec
            }?,
        })
    }
}

impl Encode for Uint64ArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.len() as u32);
        for item in self.x.iter() {
            bb.write_var_uint64(*item);
        }
    }
}

impl Decode for Uint64ArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint64()?);
                }
                vec
            }?,
        })
    }
}

impl Encode for FloatArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.len() as u32);
        for item in self.x.iter() {
            bb.write_var_float(*item);
        }
    }
}

impl Decode for FloatArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_float()?);
                }
                vec
            }?,
        })
    }
}

impl Encode for Float16ArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.len() as u32);
        for item in self.x.iter() {
            bb.write_var_float(*item);
        }
    }
}

impl Decode for Float16ArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_float()?);
                }
                vec
            }?,
        })
    }
}

impl Encode for DoubleArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.len() as u32);
        for item in self.x.iter() {
            bb.write_double(*item);
        }
    }
}

impl Decode for DoubleArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_double()?);
                }
                vec
            }?,
        })
    }
}

impl Encode for StringArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.len() as u32);
        for item in self.x.iter() {
            bb.write_string(item);
        }
    }
}

impl Decode for StringArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_string()?);
                }
                vec
            }?,
        })
    }
}

impl Encode for BytesArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.len() as u32);
        for item in self.x.iter() {
            bb.write_bytes(item);
        }
    }
}

impl Decode for BytesArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_bytes()?);
                }
                vec
            }?,
        })
    }
}

impl Encode for CompoundArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_var_uint(self.x.len() as u32);
        for item in self.x.iter() {
            bb.write_var_uint(*item);
        }
        bb.write_var_uint(self.y.len() as u32);
        for item in self.y.iter() {
            bb.write_var_uint(*item);
        }
    }
}

impl Decode for CompoundArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            x: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint()?);
                }
                vec
            }?,
            y: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint()?);
                }
                vec
            }?,
        })
    }
}

impl Encode for BoolArrayMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_bool(*item);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for BoolArrayMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_bool()?);
                }
                vec
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in BoolArrayMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for ByteArrayMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_byte(*item);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for ByteArrayMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_byte()?);
                }
                vec
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in ByteArrayMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for IntArrayMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_var_int(*item);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for IntArrayMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_int()?);
                }
                vec
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in IntArrayMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for UintArrayMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_var_uint(*item);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for UintArrayMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint()?);
                }
                vec
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in UintArrayMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for Int64ArrayMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_var_int64(*item);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for Int64ArrayMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_int64()?);
                }
                vec
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in Int64ArrayMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for Uint64ArrayMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_var_uint64(*item);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for Uint64ArrayMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint64()?);
                }
                vec
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in Uint64ArrayMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for FloatArrayMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_var_float(*item);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for FloatArrayMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_float()?);
                }
                vec
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in FloatArrayMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for Float16ArrayMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_var_float(*item);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for Float16ArrayMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_float()?);
                }
                vec
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in Float16ArrayMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for DoubleArrayMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_double(*item);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for DoubleArrayMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_double()?);
                }
                vec
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in DoubleArrayMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for StringArrayMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_string(item);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for StringArrayMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_string()?);
                }
                vec
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in StringArrayMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for BytesArrayMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_bytes(item);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for BytesArrayMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_bytes()?);
                }
                vec
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in BytesArrayMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for CompoundArrayMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_var_uint(*item);
            }
        }
        if let Some(ref value) = self.y {
            bb.write_var_uint(2);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_var_uint(*item);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for CompoundArrayMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint()?);
                }
                vec
            }?),
                2 => result.y = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint()?);
                }
                vec
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in CompoundArrayMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for RecursiveMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.x {
            bb.write_var_uint(1);
            value.encode(bb);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for RecursiveMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.x = Some(RecursiveMessage::decode(bb)?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in RecursiveMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for NonDeprecatedMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.a {
            bb.write_var_uint(1);
            bb.write_var_uint(*value);
        }
        if let Some(ref value) = self.b {
            bb.write_var_uint(2);
            bb.write_var_uint(*value);
        }
        if let Some(ref value) = self.c {
            bb.write_var_uint(3);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_var_uint(*item);
            }
        }
        if let Some(ref value) = self.d {
            bb.write_var_uint(4);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_var_uint(*item);
            }
        }
        if let Some(ref value) = self.e {
            bb.write_var_uint(5);
            value.encode(bb);
        }
        if let Some(ref value) = self.f {
            bb.write_var_uint(6);
            value.encode(bb);
        }
        if let Some(ref value) = self.g {
            bb.write_var_uint(7);
            bb.write_var_uint(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for NonDeprecatedMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.a = Some(bb.read_var_uint()?),
                2 => result.b = Some(bb.read_var_uint()?),
                3 => result.c = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint()?);
                }
                vec
            }?),
                4 => result.d = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint()?);
                }
                vec
            }?),
                5 => result.e = Some(ByteStruct::decode(bb)?),
                6 => result.f = Some(ByteStruct::decode(bb)?),
                7 => result.g = Some(bb.read_var_uint()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in NonDeprecatedMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for DeprecatedMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.a {
            bb.write_var_uint(1);
            bb.write_var_uint(*value);
        }
        if let Some(ref value) = self.c {
            bb.write_var_uint(3);
            bb.write_var_uint(value.len() as u32);
            for item in value.iter() {
                bb.write_var_uint(*item);
            }
        }
        if let Some(ref value) = self.e {
            bb.write_var_uint(5);
            value.encode(bb);
        }
        if let Some(ref value) = self.g {
            bb.write_var_uint(7);
            bb.write_var_uint(*value);
        }
        bb.write_var_uint(0);
    }
}

impl Decode for DeprecatedMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.a = Some(bb.read_var_uint()?),
                3 => result.c = Some({
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint()?);
                }
                vec
            }?),
                5 => result.e = Some(ByteStruct::decode(bb)?),
                7 => result.g = Some(bb.read_var_uint()?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in DeprecatedMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for MapMessage {
    fn encode(&self, bb: &mut ByteBuffer) {
        if let Some(ref value) = self.metadata {
            bb.write_var_uint(1);
            bb.write_var_uint(value.len() as u32);
            for (key, val) in value.iter() {
                bb.write_string(key);
                bb.write_var_int(*val);
            }
        }
        if let Some(ref value) = self.reverse {
            bb.write_var_uint(2);
            bb.write_var_uint(value.len() as u32);
            for (key, val) in value.iter() {
                bb.write_var_uint(*key as u32);
                bb.write_string(val);
            }
        }
        bb.write_var_uint(0);
    }
}

impl Decode for MapMessage {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        let mut result = Self::default();
        loop {
            let field_id = bb.read_var_uint()?;
            match field_id {
                0 => return Ok(result),
                1 => result.metadata = Some({
                let count = bb.read_var_uint()? as usize;
                let mut map = HashMap::with_capacity(count);
                for _ in 0..count {
                    let key = bb.read_string()?;
                    let value = bb.read_var_int()?;
                    map.insert(key, value);
                }
                map
            }?),
                2 => result.reverse = Some({
                let count = bb.read_var_uint()? as usize;
                let mut map = HashMap::with_capacity(count);
                for _ in 0..count {
                    let key = bb.read_var_uint()? as i32;
                    let value = bb.read_string()?;
                    map.insert(key, value);
                }
                map
            }?),
                unknown => return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("unknown field id {} in MapMessage", unknown)
                )),
            }
        }
    }
}

impl Encode for FixedArrayStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        for item in self.position.iter() {
            bb.write_var_float(**item);
        }
        for item in self.indices.iter() {
            bb.write_var_int(**item);
        }
    }
}

impl Decode for FixedArrayStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            position: {
                let mut arr: [_; 4] = Default::default();
                for item in arr.iter_mut() {
                    *item = bb.read_var_float()?;
                }
                arr
            }?,
            indices: {
                let mut arr: [_; 8] = Default::default();
                for item in arr.iter_mut() {
                    *item = bb.read_var_int()?;
                }
                arr
            }?,
        })
    }
}

impl Encode for SortedStruct {
    fn encode(&self, bb: &mut ByteBuffer) {
        bb.write_bool(*self.a1);
        bb.write_byte(*self.b1);
        bb.write_var_int(*self.c1);
        bb.write_var_uint(*self.d1);
        bb.write_var_float(*self.e1);
        bb.write_var_float(*self.e1h);
        bb.write_double(*self.e1d);
        bb.write_string(self.f1);
        bb.write_var_int64(*self.g1);
        bb.write_var_uint64(*self.h1);
        bb.write_bool(*self.a2);
        bb.write_byte(*self.b2);
        bb.write_var_int(*self.c2);
        bb.write_var_uint(*self.d2);
        bb.write_var_float(*self.e2);
        bb.write_var_float(*self.e2h);
        bb.write_double(*self.e2d);
        bb.write_string(self.f2);
        bb.write_var_int64(*self.g2);
        bb.write_var_uint64(*self.h2);
        bb.write_var_uint(self.a3.len() as u32);
        for item in self.a3.iter() {
            bb.write_bool(*item);
        }
        bb.write_var_uint(self.b3.len() as u32);
        for item in self.b3.iter() {
            bb.write_byte(*item);
        }
        bb.write_var_uint(self.c3.len() as u32);
        for item in self.c3.iter() {
            bb.write_var_int(*item);
        }
        bb.write_var_uint(self.d3.len() as u32);
        for item in self.d3.iter() {
            bb.write_var_uint(*item);
        }
        bb.write_var_uint(self.e3.len() as u32);
        for item in self.e3.iter() {
            bb.write_var_float(*item);
        }
        bb.write_var_uint(self.e3h.len() as u32);
        for item in self.e3h.iter() {
            bb.write_var_float(*item);
        }
        bb.write_var_uint(self.e3d.len() as u32);
        for item in self.e3d.iter() {
            bb.write_double(*item);
        }
        bb.write_var_uint(self.f3.len() as u32);
        for item in self.f3.iter() {
            bb.write_string(item);
        }
        bb.write_var_uint(self.g3.len() as u32);
        for item in self.g3.iter() {
            bb.write_var_int64(*item);
        }
        bb.write_var_uint(self.h3.len() as u32);
        for item in self.h3.iter() {
            bb.write_var_uint64(*item);
        }
    }
}

impl Decode for SortedStruct {
    fn decode(bb: &mut ByteBuffer) -> Result<Self> {
        Ok(Self {
            a1: bb.read_bool()?,
            b1: bb.read_byte()?,
            c1: bb.read_var_int()?,
            d1: bb.read_var_uint()?,
            e1: bb.read_var_float()?,
            e1h: bb.read_var_float()?,
            e1d: bb.read_double()?,
            f1: bb.read_string()?,
            g1: bb.read_var_int64()?,
            h1: bb.read_var_uint64()?,
            a2: bb.read_bool()?,
            b2: bb.read_byte()?,
            c2: bb.read_var_int()?,
            d2: bb.read_var_uint()?,
            e2: bb.read_var_float()?,
            e2h: bb.read_var_float()?,
            e2d: bb.read_double()?,
            f2: bb.read_string()?,
            g2: bb.read_var_int64()?,
            h2: bb.read_var_uint64()?,
            a3: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_bool()?);
                }
                vec
            }?,
            b3: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_byte()?);
                }
                vec
            }?,
            c3: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_int()?);
                }
                vec
            }?,
            d3: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint()?);
                }
                vec
            }?,
            e3: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_float()?);
                }
                vec
            }?,
            e3h: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_float()?);
                }
                vec
            }?,
            e3d: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_double()?);
                }
                vec
            }?,
            f3: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_string()?);
                }
                vec
            }?,
            g3: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_int64()?);
                }
                vec
            }?,
            h3: {
                let count = bb.read_var_uint()? as usize;
                let mut vec = Vec::with_capacity(count);
                for _ in 0..count {
                    vec.push(bb.read_var_uint64()?);
                }
                vec
            }?,
        })
    }
}

// ============================================================================
// Schema Metadata
// ============================================================================

/// Schema version information.
pub mod schema {
    pub const PACKAGE: Option<&str> = Some("test");
    pub const DEFINITION_COUNT: usize = 58;
}

}
